// This file is generated by rust-protobuf 2.0.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct TransactionOptions {
    // message oneof groups
    pub mode: ::std::option::Option<TransactionOptions_oneof_mode>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum TransactionOptions_oneof_mode {
    read_write(TransactionOptions_ReadWrite),
    read_only(TransactionOptions_ReadOnly),
}

impl TransactionOptions {
    pub fn new() -> TransactionOptions {
        ::std::default::Default::default()
    }

    // .google.spanner.v1.TransactionOptions.ReadWrite read_write = 1;

    pub fn clear_read_write(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_read_write(&self) -> bool {
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_write(&mut self, v: TransactionOptions_ReadWrite) {
        self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_write(&mut self) -> &mut TransactionOptions_ReadWrite {
        if let ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(_)) = self.mode {
        } else {
            self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(TransactionOptions_ReadWrite::new()));
        }
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_write(&mut self) -> TransactionOptions_ReadWrite {
        if self.has_read_write() {
            match self.mode.take() {
                ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(v)) => v,
                _ => panic!(),
            }
        } else {
            TransactionOptions_ReadWrite::new()
        }
    }

    pub fn get_read_write(&self) -> &TransactionOptions_ReadWrite {
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(ref v)) => v,
            _ => TransactionOptions_ReadWrite::default_instance(),
        }
    }

    // .google.spanner.v1.TransactionOptions.ReadOnly read_only = 2;

    pub fn clear_read_only(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_read_only(&self) -> bool {
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_only(&mut self, v: TransactionOptions_ReadOnly) {
        self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_only(&mut self) -> &mut TransactionOptions_ReadOnly {
        if let ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(_)) = self.mode {
        } else {
            self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(TransactionOptions_ReadOnly::new()));
        }
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_only(&mut self) -> TransactionOptions_ReadOnly {
        if self.has_read_only() {
            match self.mode.take() {
                ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(v)) => v,
                _ => panic!(),
            }
        } else {
            TransactionOptions_ReadOnly::new()
        }
    }

    pub fn get_read_only(&self) -> &TransactionOptions_ReadOnly {
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(ref v)) => v,
            _ => TransactionOptions_ReadOnly::default_instance(),
        }
    }
}

impl ::protobuf::Message for TransactionOptions {
    fn is_initialized(&self) -> bool {
        if let Some(TransactionOptions_oneof_mode::read_write(ref v)) = self.mode {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TransactionOptions_oneof_mode::read_only(ref v)) = self.mode {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.mode {
            match v {
                &TransactionOptions_oneof_mode::read_write(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TransactionOptions_oneof_mode::read_only(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.mode {
            match v {
                &TransactionOptions_oneof_mode::read_write(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TransactionOptions_oneof_mode::read_only(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionOptions {
        TransactionOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TransactionOptions_ReadWrite>(
                    "read_write",
                    TransactionOptions::has_read_write,
                    TransactionOptions::get_read_write,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TransactionOptions_ReadOnly>(
                    "read_only",
                    TransactionOptions::has_read_only,
                    TransactionOptions::get_read_only,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionOptions>(
                    "TransactionOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionOptions {
        static mut instance: ::protobuf::lazy::Lazy<TransactionOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionOptions,
        };
        unsafe {
            instance.get(TransactionOptions::new)
        }
    }
}

impl ::protobuf::Clear for TransactionOptions {
    fn clear(&mut self) {
        self.clear_read_write();
        self.clear_read_only();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionOptions_ReadWrite {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl TransactionOptions_ReadWrite {
    pub fn new() -> TransactionOptions_ReadWrite {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TransactionOptions_ReadWrite {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionOptions_ReadWrite {
        TransactionOptions_ReadWrite::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<TransactionOptions_ReadWrite>(
                    "TransactionOptions_ReadWrite",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionOptions_ReadWrite {
        static mut instance: ::protobuf::lazy::Lazy<TransactionOptions_ReadWrite> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionOptions_ReadWrite,
        };
        unsafe {
            instance.get(TransactionOptions_ReadWrite::new)
        }
    }
}

impl ::protobuf::Clear for TransactionOptions_ReadWrite {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionOptions_ReadWrite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionOptions_ReadWrite {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionOptions_ReadOnly {
    // message fields
    pub return_read_timestamp: bool,
    // message oneof groups
    pub timestamp_bound: ::std::option::Option<TransactionOptions_ReadOnly_oneof_timestamp_bound>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum TransactionOptions_ReadOnly_oneof_timestamp_bound {
    strong(bool),
    min_read_timestamp(::protobuf::well_known_types::Timestamp),
    max_staleness(::protobuf::well_known_types::Duration),
    read_timestamp(::protobuf::well_known_types::Timestamp),
    exact_staleness(::protobuf::well_known_types::Duration),
}

impl TransactionOptions_ReadOnly {
    pub fn new() -> TransactionOptions_ReadOnly {
        ::std::default::Default::default()
    }

    // bool strong = 1;

    pub fn clear_strong(&mut self) {
        self.timestamp_bound = ::std::option::Option::None;
    }

    pub fn has_strong(&self) -> bool {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::strong(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_strong(&mut self, v: bool) {
        self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::strong(v))
    }

    pub fn get_strong(&self) -> bool {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::strong(v)) => v,
            _ => false,
        }
    }

    // .google.protobuf.Timestamp min_read_timestamp = 2;

    pub fn clear_min_read_timestamp(&mut self) {
        self.timestamp_bound = ::std::option::Option::None;
    }

    pub fn has_min_read_timestamp(&self) -> bool {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_min_read_timestamp(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_min_read_timestamp(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if let ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(_)) = self.timestamp_bound {
        } else {
            self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(::protobuf::well_known_types::Timestamp::new()));
        }
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_min_read_timestamp(&mut self) -> ::protobuf::well_known_types::Timestamp {
        if self.has_min_read_timestamp() {
            match self.timestamp_bound.take() {
                ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Timestamp::new()
        }
    }

    pub fn get_min_read_timestamp(&self) -> &::protobuf::well_known_types::Timestamp {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(ref v)) => v,
            _ => ::protobuf::well_known_types::Timestamp::default_instance(),
        }
    }

    // .google.protobuf.Duration max_staleness = 3;

    pub fn clear_max_staleness(&mut self) {
        self.timestamp_bound = ::std::option::Option::None;
    }

    pub fn has_max_staleness(&self) -> bool {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_max_staleness(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(v))
    }

    // Mutable pointer to the field.
    pub fn mut_max_staleness(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if let ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(_)) = self.timestamp_bound {
        } else {
            self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(::protobuf::well_known_types::Duration::new()));
        }
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_max_staleness(&mut self) -> ::protobuf::well_known_types::Duration {
        if self.has_max_staleness() {
            match self.timestamp_bound.take() {
                ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Duration::new()
        }
    }

    pub fn get_max_staleness(&self) -> &::protobuf::well_known_types::Duration {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(ref v)) => v,
            _ => ::protobuf::well_known_types::Duration::default_instance(),
        }
    }

    // .google.protobuf.Timestamp read_timestamp = 4;

    pub fn clear_read_timestamp(&mut self) {
        self.timestamp_bound = ::std::option::Option::None;
    }

    pub fn has_read_timestamp(&self) -> bool {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_timestamp(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_timestamp(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if let ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(_)) = self.timestamp_bound {
        } else {
            self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(::protobuf::well_known_types::Timestamp::new()));
        }
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_timestamp(&mut self) -> ::protobuf::well_known_types::Timestamp {
        if self.has_read_timestamp() {
            match self.timestamp_bound.take() {
                ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Timestamp::new()
        }
    }

    pub fn get_read_timestamp(&self) -> &::protobuf::well_known_types::Timestamp {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(ref v)) => v,
            _ => ::protobuf::well_known_types::Timestamp::default_instance(),
        }
    }

    // .google.protobuf.Duration exact_staleness = 5;

    pub fn clear_exact_staleness(&mut self) {
        self.timestamp_bound = ::std::option::Option::None;
    }

    pub fn has_exact_staleness(&self) -> bool {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_exact_staleness(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(v))
    }

    // Mutable pointer to the field.
    pub fn mut_exact_staleness(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if let ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(_)) = self.timestamp_bound {
        } else {
            self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(::protobuf::well_known_types::Duration::new()));
        }
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_exact_staleness(&mut self) -> ::protobuf::well_known_types::Duration {
        if self.has_exact_staleness() {
            match self.timestamp_bound.take() {
                ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Duration::new()
        }
    }

    pub fn get_exact_staleness(&self) -> &::protobuf::well_known_types::Duration {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(ref v)) => v,
            _ => ::protobuf::well_known_types::Duration::default_instance(),
        }
    }

    // bool return_read_timestamp = 6;

    pub fn clear_return_read_timestamp(&mut self) {
        self.return_read_timestamp = false;
    }

    // Param is passed by value, moved
    pub fn set_return_read_timestamp(&mut self, v: bool) {
        self.return_read_timestamp = v;
    }

    pub fn get_return_read_timestamp(&self) -> bool {
        self.return_read_timestamp
    }
}

impl ::protobuf::Message for TransactionOptions_ReadOnly {
    fn is_initialized(&self) -> bool {
        if let Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(ref v)) = self.timestamp_bound {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(ref v)) = self.timestamp_bound {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(ref v)) = self.timestamp_bound {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(ref v)) = self.timestamp_bound {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::strong(is.read_bool()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_read_timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.return_read_timestamp != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.timestamp_bound {
            match v {
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::strong(v) => {
                    my_size += 2;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.return_read_timestamp != false {
            os.write_bool(6, self.return_read_timestamp)?;
        }
        if let ::std::option::Option::Some(ref v) = self.timestamp_bound {
            match v {
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::strong(v) => {
                    os.write_bool(1, v)?;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionOptions_ReadOnly {
        TransactionOptions_ReadOnly::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                    "strong",
                    TransactionOptions_ReadOnly::has_strong,
                    TransactionOptions_ReadOnly::get_strong,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Timestamp>(
                    "min_read_timestamp",
                    TransactionOptions_ReadOnly::has_min_read_timestamp,
                    TransactionOptions_ReadOnly::get_min_read_timestamp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Duration>(
                    "max_staleness",
                    TransactionOptions_ReadOnly::has_max_staleness,
                    TransactionOptions_ReadOnly::get_max_staleness,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Timestamp>(
                    "read_timestamp",
                    TransactionOptions_ReadOnly::has_read_timestamp,
                    TransactionOptions_ReadOnly::get_read_timestamp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Duration>(
                    "exact_staleness",
                    TransactionOptions_ReadOnly::has_exact_staleness,
                    TransactionOptions_ReadOnly::get_exact_staleness,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "return_read_timestamp",
                    |m: &TransactionOptions_ReadOnly| { &m.return_read_timestamp },
                    |m: &mut TransactionOptions_ReadOnly| { &mut m.return_read_timestamp },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionOptions_ReadOnly>(
                    "TransactionOptions_ReadOnly",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionOptions_ReadOnly {
        static mut instance: ::protobuf::lazy::Lazy<TransactionOptions_ReadOnly> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionOptions_ReadOnly,
        };
        unsafe {
            instance.get(TransactionOptions_ReadOnly::new)
        }
    }
}

impl ::protobuf::Clear for TransactionOptions_ReadOnly {
    fn clear(&mut self) {
        self.clear_strong();
        self.clear_min_read_timestamp();
        self.clear_max_staleness();
        self.clear_read_timestamp();
        self.clear_exact_staleness();
        self.clear_return_read_timestamp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionOptions_ReadOnly {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionOptions_ReadOnly {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction {
    // message fields
    pub id: ::std::vec::Vec<u8>,
    pub read_timestamp: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Transaction {
    pub fn new() -> Transaction {
        ::std::default::Default::default()
    }

    // bytes id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }

    pub fn get_id(&self) -> &[u8] {
        &self.id
    }

    // .google.protobuf.Timestamp read_timestamp = 2;

    pub fn clear_read_timestamp(&mut self) {
        self.read_timestamp.clear();
    }

    pub fn has_read_timestamp(&self) -> bool {
        self.read_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_timestamp(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.read_timestamp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_read_timestamp(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.read_timestamp.is_none() {
            self.read_timestamp.set_default();
        }
        self.read_timestamp.as_mut().unwrap()
    }

    // Take field
    pub fn take_read_timestamp(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.read_timestamp.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_read_timestamp(&self) -> &::protobuf::well_known_types::Timestamp {
        self.read_timestamp.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
}

impl ::protobuf::Message for Transaction {
    fn is_initialized(&self) -> bool {
        for v in &self.read_timestamp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.read_timestamp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.id);
        }
        if let Some(ref v) = self.read_timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_bytes(1, &self.id)?;
        }
        if let Some(ref v) = self.read_timestamp.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction {
        Transaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "id",
                    |m: &Transaction| { &m.id },
                    |m: &mut Transaction| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "read_timestamp",
                    |m: &Transaction| { &m.read_timestamp },
                    |m: &mut Transaction| { &mut m.read_timestamp },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Transaction>(
                    "Transaction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Transaction {
        static mut instance: ::protobuf::lazy::Lazy<Transaction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Transaction,
        };
        unsafe {
            instance.get(Transaction::new)
        }
    }
}

impl ::protobuf::Clear for Transaction {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_read_timestamp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionSelector {
    // message oneof groups
    pub selector: ::std::option::Option<TransactionSelector_oneof_selector>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum TransactionSelector_oneof_selector {
    single_use(TransactionOptions),
    id(::std::vec::Vec<u8>),
    begin(TransactionOptions),
}

impl TransactionSelector {
    pub fn new() -> TransactionSelector {
        ::std::default::Default::default()
    }

    // .google.spanner.v1.TransactionOptions single_use = 1;

    pub fn clear_single_use(&mut self) {
        self.selector = ::std::option::Option::None;
    }

    pub fn has_single_use(&self) -> bool {
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_single_use(&mut self, v: TransactionOptions) {
        self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(v))
    }

    // Mutable pointer to the field.
    pub fn mut_single_use(&mut self) -> &mut TransactionOptions {
        if let ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(_)) = self.selector {
        } else {
            self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(TransactionOptions::new()));
        }
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_single_use(&mut self) -> TransactionOptions {
        if self.has_single_use() {
            match self.selector.take() {
                ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(v)) => v,
                _ => panic!(),
            }
        } else {
            TransactionOptions::new()
        }
    }

    pub fn get_single_use(&self) -> &TransactionOptions {
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(ref v)) => v,
            _ => TransactionOptions::default_instance(),
        }
    }

    // bytes id = 2;

    pub fn clear_id(&mut self) {
        self.selector = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(TransactionSelector_oneof_selector::id(_)) = self.selector {
        } else {
            self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::id(::std::vec::Vec::new()));
        }
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_id() {
            match self.selector.take() {
                ::std::option::Option::Some(TransactionSelector_oneof_selector::id(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    pub fn get_id(&self) -> &[u8] {
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::id(ref v)) => v,
            _ => &[],
        }
    }

    // .google.spanner.v1.TransactionOptions begin = 3;

    pub fn clear_begin(&mut self) {
        self.selector = ::std::option::Option::None;
    }

    pub fn has_begin(&self) -> bool {
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_begin(&mut self, v: TransactionOptions) {
        self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(v))
    }

    // Mutable pointer to the field.
    pub fn mut_begin(&mut self) -> &mut TransactionOptions {
        if let ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(_)) = self.selector {
        } else {
            self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(TransactionOptions::new()));
        }
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_begin(&mut self) -> TransactionOptions {
        if self.has_begin() {
            match self.selector.take() {
                ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(v)) => v,
                _ => panic!(),
            }
        } else {
            TransactionOptions::new()
        }
    }

    pub fn get_begin(&self) -> &TransactionOptions {
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(ref v)) => v,
            _ => TransactionOptions::default_instance(),
        }
    }
}

impl ::protobuf::Message for TransactionSelector {
    fn is_initialized(&self) -> bool {
        if let Some(TransactionSelector_oneof_selector::single_use(ref v)) = self.selector {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TransactionSelector_oneof_selector::begin(ref v)) = self.selector {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::id(is.read_bytes()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.selector {
            match v {
                &TransactionSelector_oneof_selector::single_use(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TransactionSelector_oneof_selector::id(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
                &TransactionSelector_oneof_selector::begin(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.selector {
            match v {
                &TransactionSelector_oneof_selector::single_use(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TransactionSelector_oneof_selector::id(ref v) => {
                    os.write_bytes(2, v)?;
                },
                &TransactionSelector_oneof_selector::begin(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionSelector {
        TransactionSelector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TransactionOptions>(
                    "single_use",
                    TransactionSelector::has_single_use,
                    TransactionSelector::get_single_use,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "id",
                    TransactionSelector::has_id,
                    TransactionSelector::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TransactionOptions>(
                    "begin",
                    TransactionSelector::has_begin,
                    TransactionSelector::get_begin,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionSelector>(
                    "TransactionSelector",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionSelector {
        static mut instance: ::protobuf::lazy::Lazy<TransactionSelector> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionSelector,
        };
        unsafe {
            instance.get(TransactionSelector::new)
        }
    }
}

impl ::protobuf::Clear for TransactionSelector {
    fn clear(&mut self) {
        self.clear_single_use();
        self.clear_id();
        self.clear_begin();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionSelector {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n#google/spanner/v1/transaction.proto\x12\x11google.spanner.v1\x1a\x1cg\
    oogle/api/annotations.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\
    \x1fgoogle/protobuf/timestamp.proto\"\xd1\x04\n\x12TransactionOptions\
    \x12P\n\nread_write\x18\x01\x20\x01(\x0b2/.google.spanner.v1.Transaction\
    Options.ReadWriteH\0R\treadWrite\x12M\n\tread_only\x18\x02\x20\x01(\x0b2\
    ..google.spanner.v1.TransactionOptions.ReadOnlyH\0R\x08readOnly\x1a\x0b\
    \n\tReadWrite\x1a\x84\x03\n\x08ReadOnly\x12\x18\n\x06strong\x18\x01\x20\
    \x01(\x08H\0R\x06strong\x12J\n\x12min_read_timestamp\x18\x02\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampH\0R\x10minReadTimestamp\x12@\n\rmax_\
    staleness\x18\x03\x20\x01(\x0b2\x19.google.protobuf.DurationH\0R\x0cmaxS\
    taleness\x12C\n\x0eread_timestamp\x18\x04\x20\x01(\x0b2\x1a.google.proto\
    buf.TimestampH\0R\rreadTimestamp\x12D\n\x0fexact_staleness\x18\x05\x20\
    \x01(\x0b2\x19.google.protobuf.DurationH\0R\x0eexactStaleness\x122\n\x15\
    return_read_timestamp\x18\x06\x20\x01(\x08R\x13returnReadTimestampB\x11\
    \n\x0ftimestamp_boundB\x06\n\x04mode\"`\n\x0bTransaction\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\x0cR\x02id\x12A\n\x0eread_timestamp\x18\x02\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\rreadTimestamp\"\xba\x01\n\x13Trans\
    actionSelector\x12F\n\nsingle_use\x18\x01\x20\x01(\x0b2%.google.spanner.\
    v1.TransactionOptionsH\0R\tsingleUse\x12\x10\n\x02id\x18\x02\x20\x01(\
    \x0cH\0R\x02id\x12=\n\x05begin\x18\x03\x20\x01(\x0b2%.google.spanner.v1.\
    TransactionOptionsH\0R\x05beginB\n\n\x08selectorB\x99\x01\n\x15com.googl\
    e.spanner.v1B\x10TransactionProtoP\x01Z8google.golang.org/genproto/googl\
    eapis/spanner/v1;spanner\xaa\x02\x17Google.Cloud.Spanner.V1\xca\x02\x17G\
    oogle\\Cloud\\Spanner\\V1J\xd5\x81\x01\n\x07\x12\x05\x0e\0\xff\x02\x01\n\
    \xbd\x04\n\x01\x0c\x12\x03\x0e\0\x122\xb2\x04\x20Copyright\x202018\x20Go\
    ogle\x20Inc.\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Ve\
    rsion\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20t\
    his\x20file\x20except\x20in\x20compliance\x20with\x20the\x20License.\n\
    \x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\
    \x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Un\
    less\x20required\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\
    \x20writing,\x20software\n\x20distributed\x20under\x20the\x20License\x20\
    is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20\
    WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20expres\
    s\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\
    \x20language\x20governing\x20permissions\x20and\n\x20limitations\x20unde\
    r\x20the\x20License.\n\n\x08\n\x01\x02\x12\x03\x10\x08\x19\n\t\n\x02\x03\
    \0\x12\x03\x12\x07%\n\t\n\x02\x03\x01\x12\x03\x13\x07'\n\t\n\x02\x03\x02\
    \x12\x03\x14\x07(\n\x08\n\x01\x08\x12\x03\x16\04\n\x0b\n\x04\x08\xe7\x07\
    \0\x12\x03\x16\04\n\x0c\n\x05\x08\xe7\x07\0\x02\x12\x03\x16\x07\x17\n\r\
    \n\x06\x08\xe7\x07\0\x02\0\x12\x03\x16\x07\x17\n\x0e\n\x07\x08\xe7\x07\0\
    \x02\0\x01\x12\x03\x16\x07\x17\n\x0c\n\x05\x08\xe7\x07\0\x07\x12\x03\x16\
    \x1a3\n\x08\n\x01\x08\x12\x03\x17\0O\n\x0b\n\x04\x08\xe7\x07\x01\x12\x03\
    \x17\0O\n\x0c\n\x05\x08\xe7\x07\x01\x02\x12\x03\x17\x07\x11\n\r\n\x06\
    \x08\xe7\x07\x01\x02\0\x12\x03\x17\x07\x11\n\x0e\n\x07\x08\xe7\x07\x01\
    \x02\0\x01\x12\x03\x17\x07\x11\n\x0c\n\x05\x08\xe7\x07\x01\x07\x12\x03\
    \x17\x14N\n\x08\n\x01\x08\x12\x03\x18\0\"\n\x0b\n\x04\x08\xe7\x07\x02\
    \x12\x03\x18\0\"\n\x0c\n\x05\x08\xe7\x07\x02\x02\x12\x03\x18\x07\x1a\n\r\
    \n\x06\x08\xe7\x07\x02\x02\0\x12\x03\x18\x07\x1a\n\x0e\n\x07\x08\xe7\x07\
    \x02\x02\0\x01\x12\x03\x18\x07\x1a\n\x0c\n\x05\x08\xe7\x07\x02\x03\x12\
    \x03\x18\x1d!\n\x08\n\x01\x08\x12\x03\x19\01\n\x0b\n\x04\x08\xe7\x07\x03\
    \x12\x03\x19\01\n\x0c\n\x05\x08\xe7\x07\x03\x02\x12\x03\x19\x07\x1b\n\r\
    \n\x06\x08\xe7\x07\x03\x02\0\x12\x03\x19\x07\x1b\n\x0e\n\x07\x08\xe7\x07\
    \x03\x02\0\x01\x12\x03\x19\x07\x1b\n\x0c\n\x05\x08\xe7\x07\x03\x07\x12\
    \x03\x19\x1e0\n\x08\n\x01\x08\x12\x03\x1a\0.\n\x0b\n\x04\x08\xe7\x07\x04\
    \x12\x03\x1a\0.\n\x0c\n\x05\x08\xe7\x07\x04\x02\x12\x03\x1a\x07\x13\n\r\
    \n\x06\x08\xe7\x07\x04\x02\0\x12\x03\x1a\x07\x13\n\x0e\n\x07\x08\xe7\x07\
    \x04\x02\0\x01\x12\x03\x1a\x07\x13\n\x0c\n\x05\x08\xe7\x07\x04\x07\x12\
    \x03\x1a\x16-\n\x08\n\x01\x08\x12\x03\x1b\04\n\x0b\n\x04\x08\xe7\x07\x05\
    \x12\x03\x1b\04\n\x0c\n\x05\x08\xe7\x07\x05\x02\x12\x03\x1b\x07\x14\n\r\
    \n\x06\x08\xe7\x07\x05\x02\0\x12\x03\x1b\x07\x14\n\x0e\n\x07\x08\xe7\x07\
    \x05\x02\0\x01\x12\x03\x1b\x07\x14\n\x0c\n\x05\x08\xe7\x07\x05\x07\x12\
    \x03\x1b\x173\n\xeaL\n\x02\x04\0\x12\x06\xf7\x01\0\xd2\x02\x01\x1a\xdbL\
    \x20#\x20Transactions\n\n\n\x20Each\x20session\x20can\x20have\x20at\x20m\
    ost\x20one\x20active\x20transaction\x20at\x20a\x20time.\x20After\x20the\
    \n\x20active\x20transaction\x20is\x20completed,\x20the\x20session\x20can\
    \x20immediately\x20be\n\x20re-used\x20for\x20the\x20next\x20transaction.\
    \x20It\x20is\x20not\x20necessary\x20to\x20create\x20a\n\x20new\x20sessio\
    n\x20for\x20each\x20transaction.\n\n\x20#\x20Transaction\x20Modes\n\n\
    \x20Cloud\x20Spanner\x20supports\x20two\x20transaction\x20modes:\n\n\x20\
    \x20\x201.\x20Locking\x20read-write.\x20This\x20type\x20of\x20transactio\
    n\x20is\x20the\x20only\x20way\n\x20\x20\x20\x20\x20\x20to\x20write\x20da\
    ta\x20into\x20Cloud\x20Spanner.\x20These\x20transactions\x20rely\x20on\n\
    \x20\x20\x20\x20\x20\x20pessimistic\x20locking\x20and,\x20if\x20necessar\
    y,\x20two-phase\x20commit.\n\x20\x20\x20\x20\x20\x20Locking\x20read-writ\
    e\x20transactions\x20may\x20abort,\x20requiring\x20the\n\x20\x20\x20\x20\
    \x20\x20application\x20to\x20retry.\n\n\x20\x20\x202.\x20Snapshot\x20rea\
    d-only.\x20This\x20transaction\x20type\x20provides\x20guaranteed\n\x20\
    \x20\x20\x20\x20\x20consistency\x20across\x20several\x20reads,\x20but\
    \x20does\x20not\x20allow\n\x20\x20\x20\x20\x20\x20writes.\x20Snapshot\
    \x20read-only\x20transactions\x20can\x20be\x20configured\x20to\n\x20\x20\
    \x20\x20\x20\x20read\x20at\x20timestamps\x20in\x20the\x20past.\x20Snapsh\
    ot\x20read-only\n\x20\x20\x20\x20\x20\x20transactions\x20do\x20not\x20ne\
    ed\x20to\x20be\x20committed.\n\n\x20For\x20transactions\x20that\x20only\
    \x20read,\x20snapshot\x20read-only\x20transactions\n\x20provide\x20simpl\
    er\x20semantics\x20and\x20are\x20almost\x20always\x20faster.\x20In\n\x20\
    particular,\x20read-only\x20transactions\x20do\x20not\x20take\x20locks,\
    \x20so\x20they\x20do\n\x20not\x20conflict\x20with\x20read-write\x20trans\
    actions.\x20As\x20a\x20consequence\x20of\x20not\n\x20taking\x20locks,\
    \x20they\x20also\x20do\x20not\x20abort,\x20so\x20retry\x20loops\x20are\
    \x20not\x20needed.\n\n\x20Transactions\x20may\x20only\x20read/write\x20d\
    ata\x20in\x20a\x20single\x20database.\x20They\n\x20may,\x20however,\x20r\
    ead/write\x20data\x20in\x20different\x20tables\x20within\x20that\n\x20da\
    tabase.\n\n\x20##\x20Locking\x20Read-Write\x20Transactions\n\n\x20Lockin\
    g\x20transactions\x20may\x20be\x20used\x20to\x20atomically\x20read-modif\
    y-write\n\x20data\x20anywhere\x20in\x20a\x20database.\x20This\x20type\
    \x20of\x20transaction\x20is\x20externally\n\x20consistent.\n\n\x20Client\
    s\x20should\x20attempt\x20to\x20minimize\x20the\x20amount\x20of\x20time\
    \x20a\x20transaction\n\x20is\x20active.\x20Faster\x20transactions\x20com\
    mit\x20with\x20higher\x20probability\n\x20and\x20cause\x20less\x20conten\
    tion.\x20Cloud\x20Spanner\x20attempts\x20to\x20keep\x20read\x20locks\n\
    \x20active\x20as\x20long\x20as\x20the\x20transaction\x20continues\x20to\
    \x20do\x20reads,\x20and\x20the\n\x20transaction\x20has\x20not\x20been\
    \x20terminated\x20by\n\x20[Commit][google.spanner.v1.Spanner.Commit]\x20\
    or\n\x20[Rollback][google.spanner.v1.Spanner.Rollback].\x20\x20Long\x20p\
    eriods\x20of\n\x20inactivity\x20at\x20the\x20client\x20may\x20cause\x20C\
    loud\x20Spanner\x20to\x20release\x20a\n\x20transaction's\x20locks\x20and\
    \x20abort\x20it.\n\n\x20Reads\x20performed\x20within\x20a\x20transaction\
    \x20acquire\x20locks\x20on\x20the\x20data\n\x20being\x20read.\x20Writes\
    \x20can\x20only\x20be\x20done\x20at\x20commit\x20time,\x20after\x20all\
    \x20reads\n\x20have\x20been\x20completed.\n\x20Conceptually,\x20a\x20rea\
    d-write\x20transaction\x20consists\x20of\x20zero\x20or\x20more\n\x20read\
    s\x20or\x20SQL\x20queries\x20followed\x20by\n\x20[Commit][google.spanner\
    .v1.Spanner.Commit].\x20At\x20any\x20time\x20before\n\x20[Commit][google\
    .spanner.v1.Spanner.Commit],\x20the\x20client\x20can\x20send\x20a\n\x20[\
    Rollback][google.spanner.v1.Spanner.Rollback]\x20request\x20to\x20abort\
    \x20the\n\x20transaction.\n\n\x20###\x20Semantics\n\n\x20Cloud\x20Spanne\
    r\x20can\x20commit\x20the\x20transaction\x20if\x20all\x20read\x20locks\
    \x20it\x20acquired\n\x20are\x20still\x20valid\x20at\x20commit\x20time,\
    \x20and\x20it\x20is\x20able\x20to\x20acquire\x20write\n\x20locks\x20for\
    \x20all\x20writes.\x20Cloud\x20Spanner\x20can\x20abort\x20the\x20transac\
    tion\x20for\x20any\n\x20reason.\x20If\x20a\x20commit\x20attempt\x20retur\
    ns\x20`ABORTED`,\x20Cloud\x20Spanner\x20guarantees\n\x20that\x20the\x20t\
    ransaction\x20has\x20not\x20modified\x20any\x20user\x20data\x20in\x20Clo\
    ud\x20Spanner.\n\n\x20Unless\x20the\x20transaction\x20commits,\x20Cloud\
    \x20Spanner\x20makes\x20no\x20guarantees\x20about\n\x20how\x20long\x20th\
    e\x20transaction's\x20locks\x20were\x20held\x20for.\x20It\x20is\x20an\
    \x20error\x20to\n\x20use\x20Cloud\x20Spanner\x20locks\x20for\x20any\x20s\
    ort\x20of\x20mutual\x20exclusion\x20other\x20than\n\x20between\x20Cloud\
    \x20Spanner\x20transactions\x20themselves.\n\n\x20###\x20Retrying\x20Abo\
    rted\x20Transactions\n\n\x20When\x20a\x20transaction\x20aborts,\x20the\
    \x20application\x20can\x20choose\x20to\x20retry\x20the\n\x20whole\x20tra\
    nsaction\x20again.\x20To\x20maximize\x20the\x20chances\x20of\x20successf\
    ully\n\x20committing\x20the\x20retry,\x20the\x20client\x20should\x20exec\
    ute\x20the\x20retry\x20in\x20the\n\x20same\x20session\x20as\x20the\x20or\
    iginal\x20attempt.\x20The\x20original\x20session's\x20lock\n\x20priority\
    \x20increases\x20with\x20each\x20consecutive\x20abort,\x20meaning\x20tha\
    t\x20each\n\x20attempt\x20has\x20a\x20slightly\x20better\x20chance\x20of\
    \x20success\x20than\x20the\x20previous.\n\n\x20Under\x20some\x20circumst\
    ances\x20(e.g.,\x20many\x20transactions\x20attempting\x20to\n\x20modify\
    \x20the\x20same\x20row(s)),\x20a\x20transaction\x20can\x20abort\x20many\
    \x20times\x20in\x20a\n\x20short\x20period\x20before\x20successfully\x20c\
    ommitting.\x20Thus,\x20it\x20is\x20not\x20a\x20good\n\x20idea\x20to\x20c\
    ap\x20the\x20number\x20of\x20retries\x20a\x20transaction\x20can\x20attem\
    pt;\n\x20instead,\x20it\x20is\x20better\x20to\x20limit\x20the\x20total\
    \x20amount\x20of\x20wall\x20time\x20spent\n\x20retrying.\n\n\x20###\x20I\
    dle\x20Transactions\n\n\x20A\x20transaction\x20is\x20considered\x20idle\
    \x20if\x20it\x20has\x20no\x20outstanding\x20reads\x20or\n\x20SQL\x20quer\
    ies\x20and\x20has\x20not\x20started\x20a\x20read\x20or\x20SQL\x20query\
    \x20within\x20the\x20last\x2010\n\x20seconds.\x20Idle\x20transactions\
    \x20can\x20be\x20aborted\x20by\x20Cloud\x20Spanner\x20so\x20that\x20they\
    \n\x20don't\x20hold\x20on\x20to\x20locks\x20indefinitely.\x20In\x20that\
    \x20case,\x20the\x20commit\x20will\n\x20fail\x20with\x20error\x20`ABORTE\
    D`.\n\n\x20If\x20this\x20behavior\x20is\x20undesirable,\x20periodically\
    \x20executing\x20a\x20simple\n\x20SQL\x20query\x20in\x20the\x20transacti\
    on\x20(e.g.,\x20`SELECT\x201`)\x20prevents\x20the\n\x20transaction\x20fr\
    om\x20becoming\x20idle.\n\n\x20##\x20Snapshot\x20Read-Only\x20Transactio\
    ns\n\n\x20Snapshot\x20read-only\x20transactions\x20provides\x20a\x20simp\
    ler\x20method\x20than\n\x20locking\x20read-write\x20transactions\x20for\
    \x20doing\x20several\x20consistent\n\x20reads.\x20However,\x20this\x20ty\
    pe\x20of\x20transaction\x20does\x20not\x20support\x20writes.\n\n\x20Snap\
    shot\x20transactions\x20do\x20not\x20take\x20locks.\x20Instead,\x20they\
    \x20work\x20by\n\x20choosing\x20a\x20Cloud\x20Spanner\x20timestamp,\x20t\
    hen\x20executing\x20all\x20reads\x20at\x20that\n\x20timestamp.\x20Since\
    \x20they\x20do\x20not\x20acquire\x20locks,\x20they\x20do\x20not\x20block\
    \n\x20concurrent\x20read-write\x20transactions.\n\n\x20Unlike\x20locking\
    \x20read-write\x20transactions,\x20snapshot\x20read-only\n\x20transactio\
    ns\x20never\x20abort.\x20They\x20can\x20fail\x20if\x20the\x20chosen\x20r\
    ead\n\x20timestamp\x20is\x20garbage\x20collected;\x20however,\x20the\x20\
    default\x20garbage\n\x20collection\x20policy\x20is\x20generous\x20enough\
    \x20that\x20most\x20applications\x20do\x20not\n\x20need\x20to\x20worry\
    \x20about\x20this\x20in\x20practice.\n\n\x20Snapshot\x20read-only\x20tra\
    nsactions\x20do\x20not\x20need\x20to\x20call\n\x20[Commit][google.spanne\
    r.v1.Spanner.Commit]\x20or\n\x20[Rollback][google.spanner.v1.Spanner.Rol\
    lback]\x20(and\x20in\x20fact\x20are\x20not\n\x20permitted\x20to\x20do\
    \x20so).\n\n\x20To\x20execute\x20a\x20snapshot\x20transaction,\x20the\
    \x20client\x20specifies\x20a\x20timestamp\n\x20bound,\x20which\x20tells\
    \x20Cloud\x20Spanner\x20how\x20to\x20choose\x20a\x20read\x20timestamp.\n\
    \n\x20The\x20types\x20of\x20timestamp\x20bound\x20are:\n\n\x20\x20\x20-\
    \x20Strong\x20(the\x20default).\n\x20\x20\x20-\x20Bounded\x20staleness.\
    \n\x20\x20\x20-\x20Exact\x20staleness.\n\n\x20If\x20the\x20Cloud\x20Span\
    ner\x20database\x20to\x20be\x20read\x20is\x20geographically\x20distribut\
    ed,\n\x20stale\x20read-only\x20transactions\x20can\x20execute\x20more\
    \x20quickly\x20than\x20strong\n\x20or\x20read-write\x20transaction,\x20b\
    ecause\x20they\x20are\x20able\x20to\x20execute\x20far\n\x20from\x20the\
    \x20leader\x20replica.\n\n\x20Each\x20type\x20of\x20timestamp\x20bound\
    \x20is\x20discussed\x20in\x20detail\x20below.\n\n\x20###\x20Strong\n\n\
    \x20Strong\x20reads\x20are\x20guaranteed\x20to\x20see\x20the\x20effects\
    \x20of\x20all\x20transactions\n\x20that\x20have\x20committed\x20before\
    \x20the\x20start\x20of\x20the\x20read.\x20Furthermore,\x20all\n\x20rows\
    \x20yielded\x20by\x20a\x20single\x20read\x20are\x20consistent\x20with\
    \x20each\x20other\x20--\x20if\n\x20any\x20part\x20of\x20the\x20read\x20o\
    bserves\x20a\x20transaction,\x20all\x20parts\x20of\x20the\x20read\n\x20s\
    ee\x20the\x20transaction.\n\n\x20Strong\x20reads\x20are\x20not\x20repeat\
    able:\x20two\x20consecutive\x20strong\x20read-only\n\x20transactions\x20\
    might\x20return\x20inconsistent\x20results\x20if\x20there\x20are\n\x20co\
    ncurrent\x20writes.\x20If\x20consistency\x20across\x20reads\x20is\x20req\
    uired,\x20the\n\x20reads\x20should\x20be\x20executed\x20within\x20a\x20t\
    ransaction\x20or\x20at\x20an\x20exact\x20read\n\x20timestamp.\n\n\x20See\
    \x20[TransactionOptions.ReadOnly.strong][google.spanner.v1.TransactionOp\
    tions.ReadOnly.strong].\n\n\x20###\x20Exact\x20Staleness\n\n\x20These\
    \x20timestamp\x20bounds\x20execute\x20reads\x20at\x20a\x20user-specified\
    \n\x20timestamp.\x20Reads\x20at\x20a\x20timestamp\x20are\x20guaranteed\
    \x20to\x20see\x20a\x20consistent\n\x20prefix\x20of\x20the\x20global\x20t\
    ransaction\x20history:\x20they\x20observe\n\x20modifications\x20done\x20\
    by\x20all\x20transactions\x20with\x20a\x20commit\x20timestamp\x20<=\n\
    \x20the\x20read\x20timestamp,\x20and\x20observe\x20none\x20of\x20the\x20\
    modifications\x20done\x20by\n\x20transactions\x20with\x20a\x20larger\x20\
    commit\x20timestamp.\x20They\x20will\x20block\x20until\n\x20all\x20confl\
    icting\x20transactions\x20that\x20may\x20be\x20assigned\x20commit\x20tim\
    estamps\n\x20<=\x20the\x20read\x20timestamp\x20have\x20finished.\n\n\x20\
    The\x20timestamp\x20can\x20either\x20be\x20expressed\x20as\x20an\x20abso\
    lute\x20Cloud\x20Spanner\x20commit\n\x20timestamp\x20or\x20a\x20stalenes\
    s\x20relative\x20to\x20the\x20current\x20time.\n\n\x20These\x20modes\x20\
    do\x20not\x20require\x20a\x20\"negotiation\x20phase\"\x20to\x20pick\x20a\
    \n\x20timestamp.\x20As\x20a\x20result,\x20they\x20execute\x20slightly\
    \x20faster\x20than\x20the\n\x20equivalent\x20boundedly\x20stale\x20concu\
    rrency\x20modes.\x20On\x20the\x20other\x20hand,\n\x20boundedly\x20stale\
    \x20reads\x20usually\x20return\x20fresher\x20results.\n\n\x20See\x20[Tra\
    nsactionOptions.ReadOnly.read_timestamp][google.spanner.v1.TransactionOp\
    tions.ReadOnly.read_timestamp]\x20and\n\x20[TransactionOptions.ReadOnly.\
    exact_staleness][google.spanner.v1.TransactionOptions.ReadOnly.exact_sta\
    leness].\n\n\x20###\x20Bounded\x20Staleness\n\n\x20Bounded\x20staleness\
    \x20modes\x20allow\x20Cloud\x20Spanner\x20to\x20pick\x20the\x20read\x20t\
    imestamp,\n\x20subject\x20to\x20a\x20user-provided\x20staleness\x20bound\
    .\x20Cloud\x20Spanner\x20chooses\x20the\n\x20newest\x20timestamp\x20with\
    in\x20the\x20staleness\x20bound\x20that\x20allows\x20execution\n\x20of\
    \x20the\x20reads\x20at\x20the\x20closest\x20available\x20replica\x20with\
    out\x20blocking.\n\n\x20All\x20rows\x20yielded\x20are\x20consistent\x20w\
    ith\x20each\x20other\x20--\x20if\x20any\x20part\x20of\n\x20the\x20read\
    \x20observes\x20a\x20transaction,\x20all\x20parts\x20of\x20the\x20read\
    \x20see\x20the\n\x20transaction.\x20Boundedly\x20stale\x20reads\x20are\
    \x20not\x20repeatable:\x20two\x20stale\n\x20reads,\x20even\x20if\x20they\
    \x20use\x20the\x20same\x20staleness\x20bound,\x20can\x20execute\x20at\n\
    \x20different\x20timestamps\x20and\x20thus\x20return\x20inconsistent\x20\
    results.\n\n\x20Boundedly\x20stale\x20reads\x20execute\x20in\x20two\x20p\
    hases:\x20the\x20first\x20phase\n\x20negotiates\x20a\x20timestamp\x20amo\
    ng\x20all\x20replicas\x20needed\x20to\x20serve\x20the\n\x20read.\x20In\
    \x20the\x20second\x20phase,\x20reads\x20are\x20executed\x20at\x20the\x20\
    negotiated\n\x20timestamp.\n\n\x20As\x20a\x20result\x20of\x20the\x20two\
    \x20phase\x20execution,\x20bounded\x20staleness\x20reads\x20are\n\x20usu\
    ally\x20a\x20little\x20slower\x20than\x20comparable\x20exact\x20stalenes\
    s\n\x20reads.\x20However,\x20they\x20are\x20typically\x20able\x20to\x20r\
    eturn\x20fresher\n\x20results,\x20and\x20are\x20more\x20likely\x20to\x20\
    execute\x20at\x20the\x20closest\x20replica.\n\n\x20Because\x20the\x20tim\
    estamp\x20negotiation\x20requires\x20up-front\x20knowledge\x20of\n\x20wh\
    ich\x20rows\x20will\x20be\x20read,\x20it\x20can\x20only\x20be\x20used\
    \x20with\x20single-use\n\x20read-only\x20transactions.\n\n\x20See\x20[Tr\
    ansactionOptions.ReadOnly.max_staleness][google.spanner.v1.TransactionOp\
    tions.ReadOnly.max_staleness]\x20and\n\x20[TransactionOptions.ReadOnly.m\
    in_read_timestamp][google.spanner.v1.TransactionOptions.ReadOnly.min_rea\
    d_timestamp].\n\n\x20###\x20Old\x20Read\x20Timestamps\x20and\x20Garbage\
    \x20Collection\n\n\x20Cloud\x20Spanner\x20continuously\x20garbage\x20col\
    lects\x20deleted\x20and\x20overwritten\x20data\n\x20in\x20the\x20backgro\
    und\x20to\x20reclaim\x20storage\x20space.\x20This\x20process\x20is\x20kn\
    own\n\x20as\x20\"version\x20GC\".\x20By\x20default,\x20version\x20GC\x20\
    reclaims\x20versions\x20after\x20they\n\x20are\x20one\x20hour\x20old.\
    \x20Because\x20of\x20this,\x20Cloud\x20Spanner\x20cannot\x20perform\x20r\
    eads\n\x20at\x20read\x20timestamps\x20more\x20than\x20one\x20hour\x20in\
    \x20the\x20past.\x20This\n\x20restriction\x20also\x20applies\x20to\x20in\
    -progress\x20reads\x20and/or\x20SQL\x20queries\x20whose\n\x20timestamp\
    \x20become\x20too\x20old\x20while\x20executing.\x20Reads\x20and\x20SQL\
    \x20queries\x20with\n\x20too-old\x20read\x20timestamps\x20fail\x20with\
    \x20the\x20error\x20`FAILED_PRECONDITION`.\n\n\x0b\n\x03\x04\0\x01\x12\
    \x04\xf7\x01\x08\x1a\nu\n\x04\x04\0\x03\0\x12\x06\xfa\x01\x02\xfc\x01\
    \x03\x1ae\x20Message\x20type\x20to\x20initiate\x20a\x20read-write\x20tra\
    nsaction.\x20Currently\x20this\n\x20transaction\x20type\x20has\x20no\x20\
    options.\n\n\r\n\x05\x04\0\x03\0\x01\x12\x04\xfa\x01\n\x13\nC\n\x04\x04\
    \0\x03\x01\x12\x06\xff\x01\x02\xc0\x02\x03\x1a3\x20Message\x20type\x20to\
    \x20initiate\x20a\x20read-only\x20transaction.\n\n\r\n\x05\x04\0\x03\x01\
    \x01\x12\x04\xff\x01\n\x12\nN\n\x06\x04\0\x03\x01\x08\0\x12\x06\x81\x02\
    \x04\xbb\x02\x05\x1a<\x20How\x20to\x20choose\x20the\x20timestamp\x20for\
    \x20the\x20read-only\x20transaction.\n\n\x0f\n\x07\x04\0\x03\x01\x08\0\
    \x01\x12\x04\x81\x02\n\x19\n_\n\x06\x04\0\x03\x01\x02\0\x12\x04\x84\x02\
    \x06\x16\x1aO\x20Read\x20at\x20a\x20timestamp\x20where\x20all\x20previou\
    sly\x20committed\x20transactions\n\x20are\x20visible.\n\n\x0f\n\x07\x04\
    \0\x03\x01\x02\0\x05\x12\x04\x84\x02\x06\n\n\x0f\n\x07\x04\0\x03\x01\x02\
    \0\x01\x12\x04\x84\x02\x0b\x11\n\x0f\n\x07\x04\0\x03\x01\x02\0\x03\x12\
    \x04\x84\x02\x14\x15\n\xc6\x03\n\x06\x04\0\x03\x01\x02\x01\x12\x04\x90\
    \x02\x067\x1a\xb5\x03\x20Executes\x20all\x20reads\x20at\x20a\x20timestam\
    p\x20>=\x20`min_read_timestamp`.\n\n\x20This\x20is\x20useful\x20for\x20r\
    equesting\x20fresher\x20data\x20than\x20some\x20previous\n\x20read,\x20o\
    r\x20data\x20that\x20is\x20fresh\x20enough\x20to\x20observe\x20the\x20ef\
    fects\x20of\x20some\n\x20previously\x20committed\x20transaction\x20whose\
    \x20timestamp\x20is\x20known.\n\n\x20Note\x20that\x20this\x20option\x20c\
    an\x20only\x20be\x20used\x20in\x20single-use\x20transactions.\n\n\x20A\
    \x20timestamp\x20in\x20RFC3339\x20UTC\x20\\\"Zulu\\\"\x20format,\x20accu\
    rate\x20to\x20nanoseconds.\n\x20Example:\x20`\"2014-10-02T15:01:23.04512\
    3456Z\"`.\n\n\x0f\n\x07\x04\0\x03\x01\x02\x01\x06\x12\x04\x90\x02\x06\
    \x1f\n\x0f\n\x07\x04\0\x03\x01\x02\x01\x01\x12\x04\x90\x02\x202\n\x0f\n\
    \x07\x04\0\x03\x01\x02\x01\x03\x12\x04\x90\x0256\n\xba\x04\n\x06\x04\0\
    \x03\x01\x02\x02\x12\x04\x9f\x02\x061\x1a\xa9\x04\x20Read\x20data\x20at\
    \x20a\x20timestamp\x20>=\x20`NOW\x20-\x20max_staleness`\n\x20seconds.\
    \x20Guarantees\x20that\x20all\x20writes\x20that\x20have\x20committed\x20\
    more\n\x20than\x20the\x20specified\x20number\x20of\x20seconds\x20ago\x20\
    are\x20visible.\x20Because\n\x20Cloud\x20Spanner\x20chooses\x20the\x20ex\
    act\x20timestamp,\x20this\x20mode\x20works\x20even\x20if\n\x20the\x20cli\
    ent's\x20local\x20clock\x20is\x20substantially\x20skewed\x20from\x20Clou\
    d\x20Spanner\n\x20commit\x20timestamps.\n\n\x20Useful\x20for\x20reading\
    \x20the\x20freshest\x20data\x20available\x20at\x20a\x20nearby\n\x20repli\
    ca,\x20while\x20bounding\x20the\x20possible\x20staleness\x20if\x20the\
    \x20local\n\x20replica\x20has\x20fallen\x20behind.\n\n\x20Note\x20that\
    \x20this\x20option\x20can\x20only\x20be\x20used\x20in\x20single-use\n\
    \x20transactions.\n\n\x0f\n\x07\x04\0\x03\x01\x02\x02\x06\x12\x04\x9f\
    \x02\x06\x1e\n\x0f\n\x07\x04\0\x03\x01\x02\x02\x01\x12\x04\x9f\x02\x1f,\
    \n\x0f\n\x07\x04\0\x03\x01\x02\x02\x03\x12\x04\x9f\x02/0\n\xb6\x04\n\x06\
    \x04\0\x03\x01\x02\x03\x12\x04\xad\x02\x063\x1a\xa5\x04\x20Executes\x20a\
    ll\x20reads\x20at\x20the\x20given\x20timestamp.\x20Unlike\x20other\x20mo\
    des,\n\x20reads\x20at\x20a\x20specific\x20timestamp\x20are\x20repeatable\
    ;\x20the\x20same\x20read\x20at\n\x20the\x20same\x20timestamp\x20always\
    \x20returns\x20the\x20same\x20data.\x20If\x20the\n\x20timestamp\x20is\
    \x20in\x20the\x20future,\x20the\x20read\x20will\x20block\x20until\x20the\
    \n\x20specified\x20timestamp,\x20modulo\x20the\x20read's\x20deadline.\n\
    \n\x20Useful\x20for\x20large\x20scale\x20consistent\x20reads\x20such\x20\
    as\x20mapreduces,\x20or\n\x20for\x20coordinating\x20many\x20reads\x20aga\
    inst\x20a\x20consistent\x20snapshot\x20of\x20the\n\x20data.\n\n\x20A\x20\
    timestamp\x20in\x20RFC3339\x20UTC\x20\\\"Zulu\\\"\x20format,\x20accurate\
    \x20to\x20nanoseconds.\n\x20Example:\x20`\"2014-10-02T15:01:23.045123456\
    Z\"`.\n\n\x0f\n\x07\x04\0\x03\x01\x02\x03\x06\x12\x04\xad\x02\x06\x1f\n\
    \x0f\n\x07\x04\0\x03\x01\x02\x03\x01\x12\x04\xad\x02\x20.\n\x0f\n\x07\
    \x04\0\x03\x01\x02\x03\x03\x12\x04\xad\x0212\n\x92\x04\n\x06\x04\0\x03\
    \x01\x02\x04\x12\x04\xba\x02\x063\x1a\x81\x04\x20Executes\x20all\x20read\
    s\x20at\x20a\x20timestamp\x20that\x20is\x20`exact_staleness`\n\x20old.\
    \x20The\x20timestamp\x20is\x20chosen\x20soon\x20after\x20the\x20read\x20\
    is\x20started.\n\n\x20Guarantees\x20that\x20all\x20writes\x20that\x20hav\
    e\x20committed\x20more\x20than\x20the\n\x20specified\x20number\x20of\x20\
    seconds\x20ago\x20are\x20visible.\x20Because\x20Cloud\x20Spanner\n\x20ch\
    ooses\x20the\x20exact\x20timestamp,\x20this\x20mode\x20works\x20even\x20\
    if\x20the\x20client's\n\x20local\x20clock\x20is\x20substantially\x20skew\
    ed\x20from\x20Cloud\x20Spanner\x20commit\n\x20timestamps.\n\n\x20Useful\
    \x20for\x20reading\x20at\x20nearby\x20replicas\x20without\x20the\x20dist\
    ributed\n\x20timestamp\x20negotiation\x20overhead\x20of\x20`max_stalenes\
    s`.\n\n\x0f\n\x07\x04\0\x03\x01\x02\x04\x06\x12\x04\xba\x02\x06\x1e\n\
    \x0f\n\x07\x04\0\x03\x01\x02\x04\x01\x12\x04\xba\x02\x1f.\n\x0f\n\x07\
    \x04\0\x03\x01\x02\x04\x03\x12\x04\xba\x0212\n\xae\x01\n\x06\x04\0\x03\
    \x01\x02\x05\x12\x04\xbf\x02\x04#\x1a\x9d\x01\x20If\x20true,\x20the\x20C\
    loud\x20Spanner-selected\x20read\x20timestamp\x20is\x20included\x20in\n\
    \x20the\x20[Transaction][google.spanner.v1.Transaction]\x20message\x20th\
    at\x20describes\x20the\x20transaction.\n\n\x11\n\x07\x04\0\x03\x01\x02\
    \x05\x04\x12\x06\xbf\x02\x04\xbb\x02\x05\n\x0f\n\x07\x04\0\x03\x01\x02\
    \x05\x05\x12\x04\xbf\x02\x04\x08\n\x0f\n\x07\x04\0\x03\x01\x02\x05\x01\
    \x12\x04\xbf\x02\t\x1e\n\x0f\n\x07\x04\0\x03\x01\x02\x05\x03\x12\x04\xbf\
    \x02!\"\n4\n\x04\x04\0\x08\0\x12\x06\xc3\x02\x02\xd1\x02\x03\x1a$\x20Req\
    uired.\x20The\x20type\x20of\x20transaction.\n\n\r\n\x05\x04\0\x08\0\x01\
    \x12\x04\xc3\x02\x08\x0c\n\xc2\x01\n\x04\x04\0\x02\0\x12\x04\xc9\x02\x04\
    \x1d\x1a\xb3\x01\x20Transaction\x20may\x20write.\n\n\x20Authorization\
    \x20to\x20begin\x20a\x20read-write\x20transaction\x20requires\n\x20`span\
    ner.databases.beginOrRollbackReadWriteTransaction`\x20permission\n\x20on\
    \x20the\x20`session`\x20resource.\n\n\r\n\x05\x04\0\x02\0\x06\x12\x04\
    \xc9\x02\x04\r\n\r\n\x05\x04\0\x02\0\x01\x12\x04\xc9\x02\x0e\x18\n\r\n\
    \x05\x04\0\x02\0\x03\x12\x04\xc9\x02\x1b\x1c\n\xbb\x01\n\x04\x04\0\x02\
    \x01\x12\x04\xd0\x02\x04\x1b\x1a\xac\x01\x20Transaction\x20will\x20not\
    \x20write.\n\n\x20Authorization\x20to\x20begin\x20a\x20read-only\x20tran\
    saction\x20requires\n\x20`spanner.databases.beginReadOnlyTransaction`\
    \x20permission\n\x20on\x20the\x20`session`\x20resource.\n\n\r\n\x05\x04\
    \0\x02\x01\x06\x12\x04\xd0\x02\x04\x0c\n\r\n\x05\x04\0\x02\x01\x01\x12\
    \x04\xd0\x02\r\x16\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\xd0\x02\x19\x1a\n\
    \x1e\n\x02\x04\x01\x12\x06\xd5\x02\0\xe7\x02\x01\x1a\x10\x20A\x20transac\
    tion.\n\n\x0b\n\x03\x04\x01\x01\x12\x04\xd5\x02\x08\x13\n\x88\x03\n\x04\
    \x04\x01\x02\0\x12\x04\xde\x02\x02\x0f\x1a\xf9\x02\x20`id`\x20may\x20be\
    \x20used\x20to\x20identify\x20the\x20transaction\x20in\x20subsequent\n\
    \x20[Read][google.spanner.v1.Spanner.Read],\n\x20[ExecuteSql][google.spa\
    nner.v1.Spanner.ExecuteSql],\n\x20[Commit][google.spanner.v1.Spanner.Com\
    mit],\x20or\n\x20[Rollback][google.spanner.v1.Spanner.Rollback]\x20calls\
    .\n\n\x20Single-use\x20read-only\x20transactions\x20do\x20not\x20have\
    \x20IDs,\x20because\n\x20single-use\x20transactions\x20do\x20not\x20supp\
    ort\x20multiple\x20requests.\n\n\x0f\n\x05\x04\x01\x02\0\x04\x12\x06\xde\
    \x02\x02\xd5\x02\x15\n\r\n\x05\x04\x01\x02\0\x05\x12\x04\xde\x02\x02\x07\
    \n\r\n\x05\x04\x01\x02\0\x01\x12\x04\xde\x02\x08\n\n\r\n\x05\x04\x01\x02\
    \0\x03\x12\x04\xde\x02\r\x0e\n\xf2\x02\n\x04\x04\x01\x02\x01\x12\x04\xe6\
    \x02\x02/\x1a\xe3\x02\x20For\x20snapshot\x20read-only\x20transactions,\
    \x20the\x20read\x20timestamp\x20chosen\n\x20for\x20the\x20transaction.\
    \x20Not\x20returned\x20by\x20default:\x20see\n\x20[TransactionOptions.Re\
    adOnly.return_read_timestamp][google.spanner.v1.TransactionOptions.ReadO\
    nly.return_read_timestamp].\n\n\x20A\x20timestamp\x20in\x20RFC3339\x20UT\
    C\x20\\\"Zulu\\\"\x20format,\x20accurate\x20to\x20nanoseconds.\n\x20Exam\
    ple:\x20`\"2014-10-02T15:01:23.045123456Z\"`.\n\n\x0f\n\x05\x04\x01\x02\
    \x01\x04\x12\x06\xe6\x02\x02\xde\x02\x0f\n\r\n\x05\x04\x01\x02\x01\x06\
    \x12\x04\xe6\x02\x02\x1b\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\xe6\x02\
    \x1c*\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\xe6\x02-.\n\x9e\x02\n\x02\
    \x04\x02\x12\x06\xee\x02\0\xff\x02\x01\x1a\x8f\x02\x20This\x20message\
    \x20is\x20used\x20to\x20select\x20the\x20transaction\x20in\x20which\x20a\
    \n\x20[Read][google.spanner.v1.Spanner.Read]\x20or\n\x20[ExecuteSql][goo\
    gle.spanner.v1.Spanner.ExecuteSql]\x20call\x20runs.\n\n\x20See\x20[Trans\
    actionOptions][google.spanner.v1.TransactionOptions]\x20for\x20more\x20i\
    nformation\x20about\x20transactions.\n\n\x0b\n\x03\x04\x02\x01\x12\x04\
    \xee\x02\x08\x1b\ni\n\x04\x04\x02\x08\0\x12\x06\xf1\x02\x02\xfe\x02\x03\
    \x1aY\x20If\x20no\x20fields\x20are\x20set,\x20the\x20default\x20is\x20a\
    \x20single\x20use\x20transaction\n\x20with\x20strong\x20concurrency.\n\n\
    \r\n\x05\x04\x02\x08\0\x01\x12\x04\xf1\x02\x08\x10\n\xa9\x01\n\x04\x04\
    \x02\x02\0\x12\x04\xf5\x02\x04&\x1a\x9a\x01\x20Execute\x20the\x20read\
    \x20or\x20SQL\x20query\x20in\x20a\x20temporary\x20transaction.\n\x20This\
    \x20is\x20the\x20most\x20efficient\x20way\x20to\x20execute\x20a\x20trans\
    action\x20that\n\x20consists\x20of\x20a\x20single\x20SQL\x20query.\n\n\r\
    \n\x05\x04\x02\x02\0\x06\x12\x04\xf5\x02\x04\x16\n\r\n\x05\x04\x02\x02\0\
    \x01\x12\x04\xf5\x02\x17!\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\xf5\x02$%\
    \nR\n\x04\x04\x02\x02\x01\x12\x04\xf8\x02\x04\x11\x1aD\x20Execute\x20the\
    \x20read\x20or\x20SQL\x20query\x20in\x20a\x20previously-started\x20trans\
    action.\n\n\r\n\x05\x04\x02\x02\x01\x05\x12\x04\xf8\x02\x04\t\n\r\n\x05\
    \x04\x02\x02\x01\x01\x12\x04\xf8\x02\n\x0c\n\r\n\x05\x04\x02\x02\x01\x03\
    \x12\x04\xf8\x02\x0f\x10\n\x98\x02\n\x04\x04\x02\x02\x02\x12\x04\xfd\x02\
    \x04!\x1a\x89\x02\x20Begin\x20a\x20new\x20transaction\x20and\x20execute\
    \x20this\x20read\x20or\x20SQL\x20query\x20in\n\x20it.\x20The\x20transact\
    ion\x20ID\x20of\x20the\x20new\x20transaction\x20is\x20returned\x20in\n\
    \x20[ResultSetMetadata.transaction][google.spanner.v1.ResultSetMetadata.\
    transaction],\x20which\x20is\x20a\x20[Transaction][google.spanner.v1.Tra\
    nsaction].\n\n\r\n\x05\x04\x02\x02\x02\x06\x12\x04\xfd\x02\x04\x16\n\r\n\
    \x05\x04\x02\x02\x02\x01\x12\x04\xfd\x02\x17\x1c\n\r\n\x05\x04\x02\x02\
    \x02\x03\x12\x04\xfd\x02\x1f\x20b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
