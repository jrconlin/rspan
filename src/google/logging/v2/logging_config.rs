// This file is generated by rust-protobuf 2.0.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct LogSink {
    // message fields
    pub name: ::std::string::String,
    pub destination: ::std::string::String,
    pub filter: ::std::string::String,
    pub output_version_format: LogSink_VersionFormat,
    pub writer_identity: ::std::string::String,
    pub include_children: bool,
    pub start_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub end_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl LogSink {
    pub fn new() -> LogSink {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // string destination = 3;

    pub fn clear_destination(&mut self) {
        self.destination.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination(&mut self, v: ::std::string::String) {
        self.destination = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination(&mut self) -> &mut ::std::string::String {
        &mut self.destination
    }

    // Take field
    pub fn take_destination(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination, ::std::string::String::new())
    }

    pub fn get_destination(&self) -> &str {
        &self.destination
    }

    // string filter = 5;

    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }

    pub fn get_filter(&self) -> &str {
        &self.filter
    }

    // .google.logging.v2.LogSink.VersionFormat output_version_format = 6;

    pub fn clear_output_version_format(&mut self) {
        self.output_version_format = LogSink_VersionFormat::VERSION_FORMAT_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_output_version_format(&mut self, v: LogSink_VersionFormat) {
        self.output_version_format = v;
    }

    pub fn get_output_version_format(&self) -> LogSink_VersionFormat {
        self.output_version_format
    }

    // string writer_identity = 8;

    pub fn clear_writer_identity(&mut self) {
        self.writer_identity.clear();
    }

    // Param is passed by value, moved
    pub fn set_writer_identity(&mut self, v: ::std::string::String) {
        self.writer_identity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_writer_identity(&mut self) -> &mut ::std::string::String {
        &mut self.writer_identity
    }

    // Take field
    pub fn take_writer_identity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.writer_identity, ::std::string::String::new())
    }

    pub fn get_writer_identity(&self) -> &str {
        &self.writer_identity
    }

    // bool include_children = 9;

    pub fn clear_include_children(&mut self) {
        self.include_children = false;
    }

    // Param is passed by value, moved
    pub fn set_include_children(&mut self, v: bool) {
        self.include_children = v;
    }

    pub fn get_include_children(&self) -> bool {
        self.include_children
    }

    // .google.protobuf.Timestamp start_time = 10;

    pub fn clear_start_time(&mut self) {
        self.start_time.clear();
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.start_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.start_time.is_none() {
            self.start_time.set_default();
        }
        self.start_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.start_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_start_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.start_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }

    // .google.protobuf.Timestamp end_time = 11;

    pub fn clear_end_time(&mut self) {
        self.end_time.clear();
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.end_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.end_time.is_none() {
            self.end_time.set_default();
        }
        self.end_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_end_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.end_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_end_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.end_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
}

impl ::protobuf::Message for LogSink {
    fn is_initialized(&self) -> bool {
        for v in &self.start_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.destination)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.output_version_format, 6, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.writer_identity)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_children = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start_time)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.destination.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.destination);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.filter);
        }
        if self.output_version_format != LogSink_VersionFormat::VERSION_FORMAT_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(6, self.output_version_format);
        }
        if !self.writer_identity.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.writer_identity);
        }
        if self.include_children != false {
            my_size += 2;
        }
        if let Some(ref v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.destination.is_empty() {
            os.write_string(3, &self.destination)?;
        }
        if !self.filter.is_empty() {
            os.write_string(5, &self.filter)?;
        }
        if self.output_version_format != LogSink_VersionFormat::VERSION_FORMAT_UNSPECIFIED {
            os.write_enum(6, self.output_version_format.value())?;
        }
        if !self.writer_identity.is_empty() {
            os.write_string(8, &self.writer_identity)?;
        }
        if self.include_children != false {
            os.write_bool(9, self.include_children)?;
        }
        if let Some(ref v) = self.start_time.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogSink {
        LogSink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &LogSink| { &m.name },
                    |m: &mut LogSink| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "destination",
                    |m: &LogSink| { &m.destination },
                    |m: &mut LogSink| { &mut m.destination },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "filter",
                    |m: &LogSink| { &m.filter },
                    |m: &mut LogSink| { &mut m.filter },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LogSink_VersionFormat>>(
                    "output_version_format",
                    |m: &LogSink| { &m.output_version_format },
                    |m: &mut LogSink| { &mut m.output_version_format },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "writer_identity",
                    |m: &LogSink| { &m.writer_identity },
                    |m: &mut LogSink| { &mut m.writer_identity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "include_children",
                    |m: &LogSink| { &m.include_children },
                    |m: &mut LogSink| { &mut m.include_children },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "start_time",
                    |m: &LogSink| { &m.start_time },
                    |m: &mut LogSink| { &mut m.start_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "end_time",
                    |m: &LogSink| { &m.end_time },
                    |m: &mut LogSink| { &mut m.end_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LogSink>(
                    "LogSink",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LogSink {
        static mut instance: ::protobuf::lazy::Lazy<LogSink> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LogSink,
        };
        unsafe {
            instance.get(LogSink::new)
        }
    }
}

impl ::protobuf::Clear for LogSink {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_destination();
        self.clear_filter();
        self.clear_output_version_format();
        self.clear_writer_identity();
        self.clear_include_children();
        self.clear_start_time();
        self.clear_end_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogSink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogSink {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LogSink_VersionFormat {
    VERSION_FORMAT_UNSPECIFIED = 0,
    V2 = 1,
    V1 = 2,
}

impl ::protobuf::ProtobufEnum for LogSink_VersionFormat {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LogSink_VersionFormat> {
        match value {
            0 => ::std::option::Option::Some(LogSink_VersionFormat::VERSION_FORMAT_UNSPECIFIED),
            1 => ::std::option::Option::Some(LogSink_VersionFormat::V2),
            2 => ::std::option::Option::Some(LogSink_VersionFormat::V1),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LogSink_VersionFormat] = &[
            LogSink_VersionFormat::VERSION_FORMAT_UNSPECIFIED,
            LogSink_VersionFormat::V2,
            LogSink_VersionFormat::V1,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("LogSink_VersionFormat", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for LogSink_VersionFormat {
}

impl ::std::default::Default for LogSink_VersionFormat {
    fn default() -> Self {
        LogSink_VersionFormat::VERSION_FORMAT_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for LogSink_VersionFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListSinksRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_token: ::std::string::String,
    pub page_size: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListSinksRequest {
    pub fn new() -> ListSinksRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;

    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    pub fn get_parent(&self) -> &str {
        &self.parent
    }

    // string page_token = 2;

    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }

    // int32 page_size = 3;

    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
}

impl ::protobuf::Message for ListSinksRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.page_token);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(2, &self.page_token)?;
        }
        if self.page_size != 0 {
            os.write_int32(3, self.page_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSinksRequest {
        ListSinksRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "parent",
                    |m: &ListSinksRequest| { &m.parent },
                    |m: &mut ListSinksRequest| { &mut m.parent },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "page_token",
                    |m: &ListSinksRequest| { &m.page_token },
                    |m: &mut ListSinksRequest| { &mut m.page_token },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "page_size",
                    |m: &ListSinksRequest| { &m.page_size },
                    |m: &mut ListSinksRequest| { &mut m.page_size },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListSinksRequest>(
                    "ListSinksRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListSinksRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListSinksRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListSinksRequest,
        };
        unsafe {
            instance.get(ListSinksRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListSinksRequest {
    fn clear(&mut self) {
        self.clear_parent();
        self.clear_page_token();
        self.clear_page_size();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSinksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSinksRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListSinksResponse {
    // message fields
    pub sinks: ::protobuf::RepeatedField<LogSink>,
    pub next_page_token: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListSinksResponse {
    pub fn new() -> ListSinksResponse {
        ::std::default::Default::default()
    }

    // repeated .google.logging.v2.LogSink sinks = 1;

    pub fn clear_sinks(&mut self) {
        self.sinks.clear();
    }

    // Param is passed by value, moved
    pub fn set_sinks(&mut self, v: ::protobuf::RepeatedField<LogSink>) {
        self.sinks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sinks(&mut self) -> &mut ::protobuf::RepeatedField<LogSink> {
        &mut self.sinks
    }

    // Take field
    pub fn take_sinks(&mut self) -> ::protobuf::RepeatedField<LogSink> {
        ::std::mem::replace(&mut self.sinks, ::protobuf::RepeatedField::new())
    }

    pub fn get_sinks(&self) -> &[LogSink] {
        &self.sinks
    }

    // string next_page_token = 2;

    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }

    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
}

impl ::protobuf::Message for ListSinksResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.sinks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sinks)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sinks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sinks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSinksResponse {
        ListSinksResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogSink>>(
                    "sinks",
                    |m: &ListSinksResponse| { &m.sinks },
                    |m: &mut ListSinksResponse| { &mut m.sinks },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "next_page_token",
                    |m: &ListSinksResponse| { &m.next_page_token },
                    |m: &mut ListSinksResponse| { &mut m.next_page_token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListSinksResponse>(
                    "ListSinksResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListSinksResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListSinksResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListSinksResponse,
        };
        unsafe {
            instance.get(ListSinksResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListSinksResponse {
    fn clear(&mut self) {
        self.clear_sinks();
        self.clear_next_page_token();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSinksResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSinksResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSinkRequest {
    // message fields
    pub sink_name: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetSinkRequest {
    pub fn new() -> GetSinkRequest {
        ::std::default::Default::default()
    }

    // string sink_name = 1;

    pub fn clear_sink_name(&mut self) {
        self.sink_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_sink_name(&mut self, v: ::std::string::String) {
        self.sink_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sink_name(&mut self) -> &mut ::std::string::String {
        &mut self.sink_name
    }

    // Take field
    pub fn take_sink_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sink_name, ::std::string::String::new())
    }

    pub fn get_sink_name(&self) -> &str {
        &self.sink_name
    }
}

impl ::protobuf::Message for GetSinkRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sink_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sink_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sink_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.sink_name.is_empty() {
            os.write_string(1, &self.sink_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSinkRequest {
        GetSinkRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sink_name",
                    |m: &GetSinkRequest| { &m.sink_name },
                    |m: &mut GetSinkRequest| { &mut m.sink_name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetSinkRequest>(
                    "GetSinkRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetSinkRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetSinkRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSinkRequest,
        };
        unsafe {
            instance.get(GetSinkRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetSinkRequest {
    fn clear(&mut self) {
        self.clear_sink_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSinkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSinkRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSinkRequest {
    // message fields
    pub parent: ::std::string::String,
    pub sink: ::protobuf::SingularPtrField<LogSink>,
    pub unique_writer_identity: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl CreateSinkRequest {
    pub fn new() -> CreateSinkRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;

    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    pub fn get_parent(&self) -> &str {
        &self.parent
    }

    // .google.logging.v2.LogSink sink = 2;

    pub fn clear_sink(&mut self) {
        self.sink.clear();
    }

    pub fn has_sink(&self) -> bool {
        self.sink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sink(&mut self, v: LogSink) {
        self.sink = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sink(&mut self) -> &mut LogSink {
        if self.sink.is_none() {
            self.sink.set_default();
        }
        self.sink.as_mut().unwrap()
    }

    // Take field
    pub fn take_sink(&mut self) -> LogSink {
        self.sink.take().unwrap_or_else(|| LogSink::new())
    }

    pub fn get_sink(&self) -> &LogSink {
        self.sink.as_ref().unwrap_or_else(|| LogSink::default_instance())
    }

    // bool unique_writer_identity = 3;

    pub fn clear_unique_writer_identity(&mut self) {
        self.unique_writer_identity = false;
    }

    // Param is passed by value, moved
    pub fn set_unique_writer_identity(&mut self, v: bool) {
        self.unique_writer_identity = v;
    }

    pub fn get_unique_writer_identity(&self) -> bool {
        self.unique_writer_identity
    }
}

impl ::protobuf::Message for CreateSinkRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.sink {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sink)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unique_writer_identity = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if let Some(ref v) = self.sink.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.unique_writer_identity != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if let Some(ref v) = self.sink.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.unique_writer_identity != false {
            os.write_bool(3, self.unique_writer_identity)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateSinkRequest {
        CreateSinkRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "parent",
                    |m: &CreateSinkRequest| { &m.parent },
                    |m: &mut CreateSinkRequest| { &mut m.parent },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogSink>>(
                    "sink",
                    |m: &CreateSinkRequest| { &m.sink },
                    |m: &mut CreateSinkRequest| { &mut m.sink },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "unique_writer_identity",
                    |m: &CreateSinkRequest| { &m.unique_writer_identity },
                    |m: &mut CreateSinkRequest| { &mut m.unique_writer_identity },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateSinkRequest>(
                    "CreateSinkRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateSinkRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateSinkRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateSinkRequest,
        };
        unsafe {
            instance.get(CreateSinkRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateSinkRequest {
    fn clear(&mut self) {
        self.clear_parent();
        self.clear_sink();
        self.clear_unique_writer_identity();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSinkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSinkRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateSinkRequest {
    // message fields
    pub sink_name: ::std::string::String,
    pub sink: ::protobuf::SingularPtrField<LogSink>,
    pub unique_writer_identity: bool,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl UpdateSinkRequest {
    pub fn new() -> UpdateSinkRequest {
        ::std::default::Default::default()
    }

    // string sink_name = 1;

    pub fn clear_sink_name(&mut self) {
        self.sink_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_sink_name(&mut self, v: ::std::string::String) {
        self.sink_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sink_name(&mut self) -> &mut ::std::string::String {
        &mut self.sink_name
    }

    // Take field
    pub fn take_sink_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sink_name, ::std::string::String::new())
    }

    pub fn get_sink_name(&self) -> &str {
        &self.sink_name
    }

    // .google.logging.v2.LogSink sink = 2;

    pub fn clear_sink(&mut self) {
        self.sink.clear();
    }

    pub fn has_sink(&self) -> bool {
        self.sink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sink(&mut self, v: LogSink) {
        self.sink = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sink(&mut self) -> &mut LogSink {
        if self.sink.is_none() {
            self.sink.set_default();
        }
        self.sink.as_mut().unwrap()
    }

    // Take field
    pub fn take_sink(&mut self) -> LogSink {
        self.sink.take().unwrap_or_else(|| LogSink::new())
    }

    pub fn get_sink(&self) -> &LogSink {
        self.sink.as_ref().unwrap_or_else(|| LogSink::default_instance())
    }

    // bool unique_writer_identity = 3;

    pub fn clear_unique_writer_identity(&mut self) {
        self.unique_writer_identity = false;
    }

    // Param is passed by value, moved
    pub fn set_unique_writer_identity(&mut self, v: bool) {
        self.unique_writer_identity = v;
    }

    pub fn get_unique_writer_identity(&self) -> bool {
        self.unique_writer_identity
    }

    // .google.protobuf.FieldMask update_mask = 4;

    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }

    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::default_instance())
    }
}

impl ::protobuf::Message for UpdateSinkRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.sink {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sink_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sink)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unique_writer_identity = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sink_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sink_name);
        }
        if let Some(ref v) = self.sink.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.unique_writer_identity != false {
            my_size += 2;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.sink_name.is_empty() {
            os.write_string(1, &self.sink_name)?;
        }
        if let Some(ref v) = self.sink.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.unique_writer_identity != false {
            os.write_bool(3, self.unique_writer_identity)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateSinkRequest {
        UpdateSinkRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sink_name",
                    |m: &UpdateSinkRequest| { &m.sink_name },
                    |m: &mut UpdateSinkRequest| { &mut m.sink_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogSink>>(
                    "sink",
                    |m: &UpdateSinkRequest| { &m.sink },
                    |m: &mut UpdateSinkRequest| { &mut m.sink },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "unique_writer_identity",
                    |m: &UpdateSinkRequest| { &m.unique_writer_identity },
                    |m: &mut UpdateSinkRequest| { &mut m.unique_writer_identity },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                    "update_mask",
                    |m: &UpdateSinkRequest| { &m.update_mask },
                    |m: &mut UpdateSinkRequest| { &mut m.update_mask },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateSinkRequest>(
                    "UpdateSinkRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateSinkRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateSinkRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateSinkRequest,
        };
        unsafe {
            instance.get(UpdateSinkRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateSinkRequest {
    fn clear(&mut self) {
        self.clear_sink_name();
        self.clear_sink();
        self.clear_unique_writer_identity();
        self.clear_update_mask();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateSinkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateSinkRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteSinkRequest {
    // message fields
    pub sink_name: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DeleteSinkRequest {
    pub fn new() -> DeleteSinkRequest {
        ::std::default::Default::default()
    }

    // string sink_name = 1;

    pub fn clear_sink_name(&mut self) {
        self.sink_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_sink_name(&mut self, v: ::std::string::String) {
        self.sink_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sink_name(&mut self) -> &mut ::std::string::String {
        &mut self.sink_name
    }

    // Take field
    pub fn take_sink_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sink_name, ::std::string::String::new())
    }

    pub fn get_sink_name(&self) -> &str {
        &self.sink_name
    }
}

impl ::protobuf::Message for DeleteSinkRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sink_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sink_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sink_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.sink_name.is_empty() {
            os.write_string(1, &self.sink_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteSinkRequest {
        DeleteSinkRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sink_name",
                    |m: &DeleteSinkRequest| { &m.sink_name },
                    |m: &mut DeleteSinkRequest| { &mut m.sink_name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteSinkRequest>(
                    "DeleteSinkRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteSinkRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteSinkRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteSinkRequest,
        };
        unsafe {
            instance.get(DeleteSinkRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteSinkRequest {
    fn clear(&mut self) {
        self.clear_sink_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteSinkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSinkRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LogExclusion {
    // message fields
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub filter: ::std::string::String,
    pub disabled: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl LogExclusion {
    pub fn new() -> LogExclusion {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // string description = 2;

    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    pub fn get_description(&self) -> &str {
        &self.description
    }

    // string filter = 3;

    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }

    pub fn get_filter(&self) -> &str {
        &self.filter
    }

    // bool disabled = 4;

    pub fn clear_disabled(&mut self) {
        self.disabled = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled(&mut self, v: bool) {
        self.disabled = v;
    }

    pub fn get_disabled(&self) -> bool {
        self.disabled
    }
}

impl ::protobuf::Message for LogExclusion {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.filter);
        }
        if self.disabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if !self.filter.is_empty() {
            os.write_string(3, &self.filter)?;
        }
        if self.disabled != false {
            os.write_bool(4, self.disabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogExclusion {
        LogExclusion::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &LogExclusion| { &m.name },
                    |m: &mut LogExclusion| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &LogExclusion| { &m.description },
                    |m: &mut LogExclusion| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "filter",
                    |m: &LogExclusion| { &m.filter },
                    |m: &mut LogExclusion| { &mut m.filter },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "disabled",
                    |m: &LogExclusion| { &m.disabled },
                    |m: &mut LogExclusion| { &mut m.disabled },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LogExclusion>(
                    "LogExclusion",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LogExclusion {
        static mut instance: ::protobuf::lazy::Lazy<LogExclusion> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LogExclusion,
        };
        unsafe {
            instance.get(LogExclusion::new)
        }
    }
}

impl ::protobuf::Clear for LogExclusion {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_description();
        self.clear_filter();
        self.clear_disabled();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogExclusion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogExclusion {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListExclusionsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_token: ::std::string::String,
    pub page_size: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListExclusionsRequest {
    pub fn new() -> ListExclusionsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;

    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    pub fn get_parent(&self) -> &str {
        &self.parent
    }

    // string page_token = 2;

    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }

    // int32 page_size = 3;

    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
}

impl ::protobuf::Message for ListExclusionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.page_token);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(2, &self.page_token)?;
        }
        if self.page_size != 0 {
            os.write_int32(3, self.page_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListExclusionsRequest {
        ListExclusionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "parent",
                    |m: &ListExclusionsRequest| { &m.parent },
                    |m: &mut ListExclusionsRequest| { &mut m.parent },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "page_token",
                    |m: &ListExclusionsRequest| { &m.page_token },
                    |m: &mut ListExclusionsRequest| { &mut m.page_token },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "page_size",
                    |m: &ListExclusionsRequest| { &m.page_size },
                    |m: &mut ListExclusionsRequest| { &mut m.page_size },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListExclusionsRequest>(
                    "ListExclusionsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListExclusionsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListExclusionsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListExclusionsRequest,
        };
        unsafe {
            instance.get(ListExclusionsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListExclusionsRequest {
    fn clear(&mut self) {
        self.clear_parent();
        self.clear_page_token();
        self.clear_page_size();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListExclusionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListExclusionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListExclusionsResponse {
    // message fields
    pub exclusions: ::protobuf::RepeatedField<LogExclusion>,
    pub next_page_token: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListExclusionsResponse {
    pub fn new() -> ListExclusionsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.logging.v2.LogExclusion exclusions = 1;

    pub fn clear_exclusions(&mut self) {
        self.exclusions.clear();
    }

    // Param is passed by value, moved
    pub fn set_exclusions(&mut self, v: ::protobuf::RepeatedField<LogExclusion>) {
        self.exclusions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_exclusions(&mut self) -> &mut ::protobuf::RepeatedField<LogExclusion> {
        &mut self.exclusions
    }

    // Take field
    pub fn take_exclusions(&mut self) -> ::protobuf::RepeatedField<LogExclusion> {
        ::std::mem::replace(&mut self.exclusions, ::protobuf::RepeatedField::new())
    }

    pub fn get_exclusions(&self) -> &[LogExclusion] {
        &self.exclusions
    }

    // string next_page_token = 2;

    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }

    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
}

impl ::protobuf::Message for ListExclusionsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.exclusions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.exclusions)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.exclusions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.exclusions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListExclusionsResponse {
        ListExclusionsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogExclusion>>(
                    "exclusions",
                    |m: &ListExclusionsResponse| { &m.exclusions },
                    |m: &mut ListExclusionsResponse| { &mut m.exclusions },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "next_page_token",
                    |m: &ListExclusionsResponse| { &m.next_page_token },
                    |m: &mut ListExclusionsResponse| { &mut m.next_page_token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListExclusionsResponse>(
                    "ListExclusionsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListExclusionsResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListExclusionsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListExclusionsResponse,
        };
        unsafe {
            instance.get(ListExclusionsResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListExclusionsResponse {
    fn clear(&mut self) {
        self.clear_exclusions();
        self.clear_next_page_token();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListExclusionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListExclusionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetExclusionRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetExclusionRequest {
    pub fn new() -> GetExclusionRequest {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }
}

impl ::protobuf::Message for GetExclusionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetExclusionRequest {
        GetExclusionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &GetExclusionRequest| { &m.name },
                    |m: &mut GetExclusionRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetExclusionRequest>(
                    "GetExclusionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetExclusionRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetExclusionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetExclusionRequest,
        };
        unsafe {
            instance.get(GetExclusionRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetExclusionRequest {
    fn clear(&mut self) {
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetExclusionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetExclusionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateExclusionRequest {
    // message fields
    pub parent: ::std::string::String,
    pub exclusion: ::protobuf::SingularPtrField<LogExclusion>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl CreateExclusionRequest {
    pub fn new() -> CreateExclusionRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;

    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    pub fn get_parent(&self) -> &str {
        &self.parent
    }

    // .google.logging.v2.LogExclusion exclusion = 2;

    pub fn clear_exclusion(&mut self) {
        self.exclusion.clear();
    }

    pub fn has_exclusion(&self) -> bool {
        self.exclusion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exclusion(&mut self, v: LogExclusion) {
        self.exclusion = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exclusion(&mut self) -> &mut LogExclusion {
        if self.exclusion.is_none() {
            self.exclusion.set_default();
        }
        self.exclusion.as_mut().unwrap()
    }

    // Take field
    pub fn take_exclusion(&mut self) -> LogExclusion {
        self.exclusion.take().unwrap_or_else(|| LogExclusion::new())
    }

    pub fn get_exclusion(&self) -> &LogExclusion {
        self.exclusion.as_ref().unwrap_or_else(|| LogExclusion::default_instance())
    }
}

impl ::protobuf::Message for CreateExclusionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.exclusion {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exclusion)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if let Some(ref v) = self.exclusion.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if let Some(ref v) = self.exclusion.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateExclusionRequest {
        CreateExclusionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "parent",
                    |m: &CreateExclusionRequest| { &m.parent },
                    |m: &mut CreateExclusionRequest| { &mut m.parent },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogExclusion>>(
                    "exclusion",
                    |m: &CreateExclusionRequest| { &m.exclusion },
                    |m: &mut CreateExclusionRequest| { &mut m.exclusion },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateExclusionRequest>(
                    "CreateExclusionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateExclusionRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateExclusionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateExclusionRequest,
        };
        unsafe {
            instance.get(CreateExclusionRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateExclusionRequest {
    fn clear(&mut self) {
        self.clear_parent();
        self.clear_exclusion();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateExclusionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateExclusionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateExclusionRequest {
    // message fields
    pub name: ::std::string::String,
    pub exclusion: ::protobuf::SingularPtrField<LogExclusion>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl UpdateExclusionRequest {
    pub fn new() -> UpdateExclusionRequest {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // .google.logging.v2.LogExclusion exclusion = 2;

    pub fn clear_exclusion(&mut self) {
        self.exclusion.clear();
    }

    pub fn has_exclusion(&self) -> bool {
        self.exclusion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exclusion(&mut self, v: LogExclusion) {
        self.exclusion = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exclusion(&mut self) -> &mut LogExclusion {
        if self.exclusion.is_none() {
            self.exclusion.set_default();
        }
        self.exclusion.as_mut().unwrap()
    }

    // Take field
    pub fn take_exclusion(&mut self) -> LogExclusion {
        self.exclusion.take().unwrap_or_else(|| LogExclusion::new())
    }

    pub fn get_exclusion(&self) -> &LogExclusion {
        self.exclusion.as_ref().unwrap_or_else(|| LogExclusion::default_instance())
    }

    // .google.protobuf.FieldMask update_mask = 3;

    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }

    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::default_instance())
    }
}

impl ::protobuf::Message for UpdateExclusionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.exclusion {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exclusion)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.exclusion.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.exclusion.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateExclusionRequest {
        UpdateExclusionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &UpdateExclusionRequest| { &m.name },
                    |m: &mut UpdateExclusionRequest| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogExclusion>>(
                    "exclusion",
                    |m: &UpdateExclusionRequest| { &m.exclusion },
                    |m: &mut UpdateExclusionRequest| { &mut m.exclusion },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                    "update_mask",
                    |m: &UpdateExclusionRequest| { &m.update_mask },
                    |m: &mut UpdateExclusionRequest| { &mut m.update_mask },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateExclusionRequest>(
                    "UpdateExclusionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateExclusionRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateExclusionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateExclusionRequest,
        };
        unsafe {
            instance.get(UpdateExclusionRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateExclusionRequest {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_exclusion();
        self.clear_update_mask();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateExclusionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateExclusionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteExclusionRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DeleteExclusionRequest {
    pub fn new() -> DeleteExclusionRequest {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }
}

impl ::protobuf::Message for DeleteExclusionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteExclusionRequest {
        DeleteExclusionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &DeleteExclusionRequest| { &m.name },
                    |m: &mut DeleteExclusionRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteExclusionRequest>(
                    "DeleteExclusionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteExclusionRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteExclusionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteExclusionRequest,
        };
        unsafe {
            instance.get(DeleteExclusionRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteExclusionRequest {
    fn clear(&mut self) {
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteExclusionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteExclusionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n&google/logging/v2/logging_config.proto\x12\x11google.logging.v2\x1a\
    \x1cgoogle/api/annotations.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a\
    \x20google/protobuf/field_mask.proto\x1a\x1fgoogle/protobuf/timestamp.pr\
    oto\"\xbc\x03\n\x07LogSink\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12\x20\n\x0bdestination\x18\x03\x20\x01(\tR\x0bdestination\x12\x16\n\
    \x06filter\x18\x05\x20\x01(\tR\x06filter\x12\\\n\x15output_version_forma\
    t\x18\x06\x20\x01(\x0e2(.google.logging.v2.LogSink.VersionFormatR\x13out\
    putVersionFormat\x12'\n\x0fwriter_identity\x18\x08\x20\x01(\tR\x0ewriter\
    Identity\x12)\n\x10include_children\x18\t\x20\x01(\x08R\x0fincludeChildr\
    en\x129\n\nstart_time\x18\n\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \tstartTime\x125\n\x08end_time\x18\x0b\x20\x01(\x0b2\x1a.google.protobuf\
    .TimestampR\x07endTime\"?\n\rVersionFormat\x12\x1e\n\x1aVERSION_FORMAT_U\
    NSPECIFIED\x10\0\x12\x06\n\x02V2\x10\x01\x12\x06\n\x02V1\x10\x02\"f\n\
    \x10ListSinksRequest\x12\x16\n\x06parent\x18\x01\x20\x01(\tR\x06parent\
    \x12\x1d\n\npage_token\x18\x02\x20\x01(\tR\tpageToken\x12\x1b\n\tpage_si\
    ze\x18\x03\x20\x01(\x05R\x08pageSize\"m\n\x11ListSinksResponse\x120\n\
    \x05sinks\x18\x01\x20\x03(\x0b2\x1a.google.logging.v2.LogSinkR\x05sinks\
    \x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\"-\n\x0eGe\
    tSinkRequest\x12\x1b\n\tsink_name\x18\x01\x20\x01(\tR\x08sinkName\"\x91\
    \x01\n\x11CreateSinkRequest\x12\x16\n\x06parent\x18\x01\x20\x01(\tR\x06p\
    arent\x12.\n\x04sink\x18\x02\x20\x01(\x0b2\x1a.google.logging.v2.LogSink\
    R\x04sink\x124\n\x16unique_writer_identity\x18\x03\x20\x01(\x08R\x14uniq\
    ueWriterIdentity\"\xd3\x01\n\x11UpdateSinkRequest\x12\x1b\n\tsink_name\
    \x18\x01\x20\x01(\tR\x08sinkName\x12.\n\x04sink\x18\x02\x20\x01(\x0b2\
    \x1a.google.logging.v2.LogSinkR\x04sink\x124\n\x16unique_writer_identity\
    \x18\x03\x20\x01(\x08R\x14uniqueWriterIdentity\x12;\n\x0bupdate_mask\x18\
    \x04\x20\x01(\x0b2\x1a.google.protobuf.FieldMaskR\nupdateMask\"0\n\x11De\
    leteSinkRequest\x12\x1b\n\tsink_name\x18\x01\x20\x01(\tR\x08sinkName\"x\
    \n\x0cLogExclusion\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x20\
    \n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescription\x12\x16\n\x06filter\
    \x18\x03\x20\x01(\tR\x06filter\x12\x1a\n\x08disabled\x18\x04\x20\x01(\
    \x08R\x08disabled\"k\n\x15ListExclusionsRequest\x12\x16\n\x06parent\x18\
    \x01\x20\x01(\tR\x06parent\x12\x1d\n\npage_token\x18\x02\x20\x01(\tR\tpa\
    geToken\x12\x1b\n\tpage_size\x18\x03\x20\x01(\x05R\x08pageSize\"\x81\x01\
    \n\x16ListExclusionsResponse\x12?\n\nexclusions\x18\x01\x20\x03(\x0b2\
    \x1f.google.logging.v2.LogExclusionR\nexclusions\x12&\n\x0fnext_page_tok\
    en\x18\x02\x20\x01(\tR\rnextPageToken\")\n\x13GetExclusionRequest\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"o\n\x16CreateExclusionReques\
    t\x12\x16\n\x06parent\x18\x01\x20\x01(\tR\x06parent\x12=\n\texclusion\
    \x18\x02\x20\x01(\x0b2\x1f.google.logging.v2.LogExclusionR\texclusion\"\
    \xa8\x01\n\x16UpdateExclusionRequest\x12\x12\n\x04name\x18\x01\x20\x01(\
    \tR\x04name\x12=\n\texclusion\x18\x02\x20\x01(\x0b2\x1f.google.logging.v\
    2.LogExclusionR\texclusion\x12;\n\x0bupdate_mask\x18\x03\x20\x01(\x0b2\
    \x1a.google.protobuf.FieldMaskR\nupdateMask\",\n\x16DeleteExclusionReque\
    st\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name2\x80\n\n\x0fConfigServi\
    ceV2\x12v\n\tListSinks\x12#.google.logging.v2.ListSinksRequest\x1a$.goog\
    le.logging.v2.ListSinksResponse\"\x1e\x82\xd3\xe4\x93\x02\x18\x12\x16/v2\
    /{parent=*/*}/sinks\x12m\n\x07GetSink\x12!.google.logging.v2.GetSinkRequ\
    est\x1a\x1a.google.logging.v2.LogSink\"#\x82\xd3\xe4\x93\x02\x1d\x12\x1b\
    /v2/{sink_name=*/*/sinks/*}\x12t\n\nCreateSink\x12$.google.logging.v2.Cr\
    eateSinkRequest\x1a\x1a.google.logging.v2.LogSink\"$\x82\xd3\xe4\x93\x02\
    \x1e\"\x16/v2/{parent=*/*}/sinks:\x04sink\x12y\n\nUpdateSink\x12$.google\
    .logging.v2.UpdateSinkRequest\x1a\x1a.google.logging.v2.LogSink\")\x82\
    \xd3\xe4\x93\x02#\x1a\x1b/v2/{sink_name=*/*/sinks/*}:\x04sink\x12o\n\nDe\
    leteSink\x12$.google.logging.v2.DeleteSinkRequest\x1a\x16.google.protobu\
    f.Empty\"#\x82\xd3\xe4\x93\x02\x1d*\x1b/v2/{sink_name=*/*/sinks/*}\x12\
    \x8a\x01\n\x0eListExclusions\x12(.google.logging.v2.ListExclusionsReques\
    t\x1a).google.logging.v2.ListExclusionsResponse\"#\x82\xd3\xe4\x93\x02\
    \x1d\x12\x1b/v2/{parent=*/*}/exclusions\x12|\n\x0cGetExclusion\x12&.goog\
    le.logging.v2.GetExclusionRequest\x1a\x1f.google.logging.v2.LogExclusion\
    \"#\x82\xd3\xe4\x93\x02\x1d\x12\x1b/v2/{name=*/*/exclusions/*}\x12\x8d\
    \x01\n\x0fCreateExclusion\x12).google.logging.v2.CreateExclusionRequest\
    \x1a\x1f.google.logging.v2.LogExclusion\".\x82\xd3\xe4\x93\x02(\"\x1b/v2\
    /{parent=*/*}/exclusions:\texclusion\x12\x8d\x01\n\x0fUpdateExclusion\
    \x12).google.logging.v2.UpdateExclusionRequest\x1a\x1f.google.logging.v2\
    .LogExclusion\".\x82\xd3\xe4\x93\x02(2\x1b/v2/{name=*/*/exclusions/*}:\t\
    exclusion\x12y\n\x0fDeleteExclusion\x12).google.logging.v2.DeleteExclusi\
    onRequest\x1a\x16.google.protobuf.Empty\"#\x82\xd3\xe4\x93\x02\x1d*\x1b/\
    v2/{name=*/*/exclusions/*}B\x9e\x01\n\x15com.google.logging.v2B\x12Loggi\
    ngConfigProtoP\x01Z8google.golang.org/genproto/googleapis/logging/v2;log\
    ging\xf8\x01\x01\xaa\x02\x17Google.Cloud.Logging.V2\xca\x02\x17Google\\C\
    loud\\Logging\\V2J\x8d\x9e\x01\n\x07\x12\x05\x0e\0\xc7\x03\x01\n\xbd\x04\
    \n\x01\x0c\x12\x03\x0e\0\x122\xb2\x04\x20Copyright\x202017\x20Google\x20\
    Inc.\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Version\
    \x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\
    \x20file\x20except\x20in\x20compliance\x20with\x20the\x20License.\n\x20Y\
    ou\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\
    \x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\
    \x20required\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20w\
    riting,\x20software\n\x20distributed\x20under\x20the\x20License\x20is\
    \x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WA\
    RRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\
    \x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\
    \x20language\x20governing\x20permissions\x20and\n\x20limitations\x20unde\
    r\x20the\x20License.\n\n\x08\n\x01\x02\x12\x03\x10\x08\x19\n\t\n\x02\x03\
    \0\x12\x03\x12\x07%\n\t\n\x02\x03\x01\x12\x03\x13\x07$\n\t\n\x02\x03\x02\
    \x12\x03\x14\x07)\n\t\n\x02\x03\x03\x12\x03\x15\x07(\n\x08\n\x01\x08\x12\
    \x03\x17\0\x1f\n\x0b\n\x04\x08\xe7\x07\0\x12\x03\x17\0\x1f\n\x0c\n\x05\
    \x08\xe7\x07\0\x02\x12\x03\x17\x07\x17\n\r\n\x06\x08\xe7\x07\0\x02\0\x12\
    \x03\x17\x07\x17\n\x0e\n\x07\x08\xe7\x07\0\x02\0\x01\x12\x03\x17\x07\x17\
    \n\x0c\n\x05\x08\xe7\x07\0\x03\x12\x03\x17\x1a\x1e\n\x08\n\x01\x08\x12\
    \x03\x18\04\n\x0b\n\x04\x08\xe7\x07\x01\x12\x03\x18\04\n\x0c\n\x05\x08\
    \xe7\x07\x01\x02\x12\x03\x18\x07\x17\n\r\n\x06\x08\xe7\x07\x01\x02\0\x12\
    \x03\x18\x07\x17\n\x0e\n\x07\x08\xe7\x07\x01\x02\0\x01\x12\x03\x18\x07\
    \x17\n\x0c\n\x05\x08\xe7\x07\x01\x07\x12\x03\x18\x1a3\n\x08\n\x01\x08\
    \x12\x03\x19\0O\n\x0b\n\x04\x08\xe7\x07\x02\x12\x03\x19\0O\n\x0c\n\x05\
    \x08\xe7\x07\x02\x02\x12\x03\x19\x07\x11\n\r\n\x06\x08\xe7\x07\x02\x02\0\
    \x12\x03\x19\x07\x11\n\x0e\n\x07\x08\xe7\x07\x02\x02\0\x01\x12\x03\x19\
    \x07\x11\n\x0c\n\x05\x08\xe7\x07\x02\x07\x12\x03\x19\x14N\n\x08\n\x01\
    \x08\x12\x03\x1a\0\"\n\x0b\n\x04\x08\xe7\x07\x03\x12\x03\x1a\0\"\n\x0c\n\
    \x05\x08\xe7\x07\x03\x02\x12\x03\x1a\x07\x1a\n\r\n\x06\x08\xe7\x07\x03\
    \x02\0\x12\x03\x1a\x07\x1a\n\x0e\n\x07\x08\xe7\x07\x03\x02\0\x01\x12\x03\
    \x1a\x07\x1a\n\x0c\n\x05\x08\xe7\x07\x03\x03\x12\x03\x1a\x1d!\n\x08\n\
    \x01\x08\x12\x03\x1b\03\n\x0b\n\x04\x08\xe7\x07\x04\x12\x03\x1b\03\n\x0c\
    \n\x05\x08\xe7\x07\x04\x02\x12\x03\x1b\x07\x1b\n\r\n\x06\x08\xe7\x07\x04\
    \x02\0\x12\x03\x1b\x07\x1b\n\x0e\n\x07\x08\xe7\x07\x04\x02\0\x01\x12\x03\
    \x1b\x07\x1b\n\x0c\n\x05\x08\xe7\x07\x04\x07\x12\x03\x1b\x1e2\n\x08\n\
    \x01\x08\x12\x03\x1c\0.\n\x0b\n\x04\x08\xe7\x07\x05\x12\x03\x1c\0.\n\x0c\
    \n\x05\x08\xe7\x07\x05\x02\x12\x03\x1c\x07\x13\n\r\n\x06\x08\xe7\x07\x05\
    \x02\0\x12\x03\x1c\x07\x13\n\x0e\n\x07\x08\xe7\x07\x05\x02\0\x01\x12\x03\
    \x1c\x07\x13\n\x0c\n\x05\x08\xe7\x07\x05\x07\x12\x03\x1c\x16-\n\x08\n\
    \x01\x08\x12\x03\x1d\04\n\x0b\n\x04\x08\xe7\x07\x06\x12\x03\x1d\04\n\x0c\
    \n\x05\x08\xe7\x07\x06\x02\x12\x03\x1d\x07\x14\n\r\n\x06\x08\xe7\x07\x06\
    \x02\0\x12\x03\x1d\x07\x14\n\x0e\n\x07\x08\xe7\x07\x06\x02\0\x01\x12\x03\
    \x1d\x07\x14\n\x0c\n\x05\x08\xe7\x07\x06\x07\x12\x03\x1d\x173\ng\n\x02\
    \x06\0\x12\x04\"\0]\x01\x1a[\x20Service\x20for\x20configuring\x20sinks\
    \x20used\x20to\x20export\x20log\x20entries\x20outside\x20of\n\x20Stackdr\
    iver\x20Logging.\n\n\n\n\x03\x06\0\x01\x12\x03\"\x08\x17\n\x1c\n\x04\x06\
    \0\x02\0\x12\x04$\x02&\x03\x1a\x0e\x20Lists\x20sinks.\n\n\x0c\n\x05\x06\
    \0\x02\0\x01\x12\x03$\x06\x0f\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03$\x10\
    \x20\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03$+<\n\x0c\n\x05\x06\0\x02\0\x04\
    \x12\x03%\x04A\n\x0f\n\x08\x06\0\x02\0\x04\xe7\x07\0\x12\x03%\x04A\n\x10\
    \n\t\x06\0\x02\0\x04\xe7\x07\0\x02\x12\x03%\x0b\x1c\n\x11\n\n\x06\0\x02\
    \0\x04\xe7\x07\0\x02\0\x12\x03%\x0b\x1c\n\x12\n\x0b\x06\0\x02\0\x04\xe7\
    \x07\0\x02\0\x01\x12\x03%\x0c\x1b\n\x10\n\t\x06\0\x02\0\x04\xe7\x07\0\
    \x08\x12\x03%\x1f@\n\x1c\n\x04\x06\0\x02\x01\x12\x04)\x02+\x03\x1a\x0e\
    \x20Gets\x20a\x20sink.\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03)\x06\r\n\
    \x0c\n\x05\x06\0\x02\x01\x02\x12\x03)\x0e\x1c\n\x0c\n\x05\x06\0\x02\x01\
    \x03\x12\x03)'.\n\x0c\n\x05\x06\0\x02\x01\x04\x12\x03*\x04F\n\x0f\n\x08\
    \x06\0\x02\x01\x04\xe7\x07\0\x12\x03*\x04F\n\x10\n\t\x06\0\x02\x01\x04\
    \xe7\x07\0\x02\x12\x03*\x0b\x1c\n\x11\n\n\x06\0\x02\x01\x04\xe7\x07\0\
    \x02\0\x12\x03*\x0b\x1c\n\x12\n\x0b\x06\0\x02\x01\x04\xe7\x07\0\x02\0\
    \x01\x12\x03*\x0c\x1b\n\x10\n\t\x06\0\x02\x01\x04\xe7\x07\0\x08\x12\x03*\
    \x1fE\n\xae\x02\n\x04\x06\0\x02\x02\x12\x041\x023\x03\x1a\x9f\x02\x20Cre\
    ates\x20a\x20sink\x20that\x20exports\x20specified\x20log\x20entries\x20t\
    o\x20a\x20destination.\x20\x20The\n\x20export\x20of\x20newly-ingested\
    \x20log\x20entries\x20begins\x20immediately,\x20unless\x20the\x20sink's\
    \n\x20`writer_identity`\x20is\x20not\x20permitted\x20to\x20write\x20to\
    \x20the\x20destination.\x20\x20A\x20sink\x20can\n\x20export\x20log\x20en\
    tries\x20only\x20from\x20the\x20resource\x20owning\x20the\x20sink.\n\n\
    \x0c\n\x05\x06\0\x02\x02\x01\x12\x031\x06\x10\n\x0c\n\x05\x06\0\x02\x02\
    \x02\x12\x031\x11\"\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x031-4\n\x0c\n\x05\
    \x06\0\x02\x02\x04\x12\x032\x04O\n\x0f\n\x08\x06\0\x02\x02\x04\xe7\x07\0\
    \x12\x032\x04O\n\x10\n\t\x06\0\x02\x02\x04\xe7\x07\0\x02\x12\x032\x0b\
    \x1c\n\x11\n\n\x06\0\x02\x02\x04\xe7\x07\0\x02\0\x12\x032\x0b\x1c\n\x12\
    \n\x0b\x06\0\x02\x02\x04\xe7\x07\0\x02\0\x01\x12\x032\x0c\x1b\n\x10\n\t\
    \x06\0\x02\x02\x04\xe7\x07\0\x08\x12\x032\x1fN\n\x81\x02\n\x04\x06\0\x02\
    \x03\x12\x049\x02;\x03\x1a\xf2\x01\x20Updates\x20a\x20sink.\x20\x20This\
    \x20method\x20replaces\x20the\x20following\x20fields\x20in\x20the\x20exi\
    sting\n\x20sink\x20with\x20values\x20from\x20the\x20new\x20sink:\x20`des\
    tination`,\x20and\x20`filter`.\n\x20The\x20updated\x20sink\x20might\x20a\
    lso\x20have\x20a\x20new\x20`writer_identity`;\x20see\x20the\n\x20`unique\
    _writer_identity`\x20field.\n\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x039\x06\
    \x10\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x039\x11\"\n\x0c\n\x05\x06\0\x02\
    \x03\x03\x12\x039-4\n\x0c\n\x05\x06\0\x02\x03\x04\x12\x03:\x04S\n\x0f\n\
    \x08\x06\0\x02\x03\x04\xe7\x07\0\x12\x03:\x04S\n\x10\n\t\x06\0\x02\x03\
    \x04\xe7\x07\0\x02\x12\x03:\x0b\x1c\n\x11\n\n\x06\0\x02\x03\x04\xe7\x07\
    \0\x02\0\x12\x03:\x0b\x1c\n\x12\n\x0b\x06\0\x02\x03\x04\xe7\x07\0\x02\0\
    \x01\x12\x03:\x0c\x1b\n\x10\n\t\x06\0\x02\x03\x04\xe7\x07\0\x08\x12\x03:\
    \x1fR\nw\n\x04\x06\0\x02\x04\x12\x04?\x02A\x03\x1ai\x20Deletes\x20a\x20s\
    ink.\x20If\x20the\x20sink\x20has\x20a\x20unique\x20`writer_identity`,\
    \x20then\x20that\n\x20service\x20account\x20is\x20also\x20deleted.\n\n\
    \x0c\n\x05\x06\0\x02\x04\x01\x12\x03?\x06\x10\n\x0c\n\x05\x06\0\x02\x04\
    \x02\x12\x03?\x11\"\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03?-B\n\x0c\n\x05\
    \x06\0\x02\x04\x04\x12\x03@\x04I\n\x0f\n\x08\x06\0\x02\x04\x04\xe7\x07\0\
    \x12\x03@\x04I\n\x10\n\t\x06\0\x02\x04\x04\xe7\x07\0\x02\x12\x03@\x0b\
    \x1c\n\x11\n\n\x06\0\x02\x04\x04\xe7\x07\0\x02\0\x12\x03@\x0b\x1c\n\x12\
    \n\x0b\x06\0\x02\x04\x04\xe7\x07\0\x02\0\x01\x12\x03@\x0c\x1b\n\x10\n\t\
    \x06\0\x02\x04\x04\xe7\x07\0\x08\x12\x03@\x1fH\n>\n\x04\x06\0\x02\x05\
    \x12\x04D\x02F\x03\x1a0\x20Lists\x20all\x20the\x20exclusions\x20in\x20a\
    \x20parent\x20resource.\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03D\x06\x14\
    \n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03D\x15*\n\x0c\n\x05\x06\0\x02\x05\
    \x03\x12\x03D5K\n\x0c\n\x05\x06\0\x02\x05\x04\x12\x03E\x04F\n\x0f\n\x08\
    \x06\0\x02\x05\x04\xe7\x07\0\x12\x03E\x04F\n\x10\n\t\x06\0\x02\x05\x04\
    \xe7\x07\0\x02\x12\x03E\x0b\x1c\n\x11\n\n\x06\0\x02\x05\x04\xe7\x07\0\
    \x02\0\x12\x03E\x0b\x1c\n\x12\n\x0b\x06\0\x02\x05\x04\xe7\x07\0\x02\0\
    \x01\x12\x03E\x0c\x1b\n\x10\n\t\x06\0\x02\x05\x04\xe7\x07\0\x08\x12\x03E\
    \x1fE\n5\n\x04\x06\0\x02\x06\x12\x04I\x02K\x03\x1a'\x20Gets\x20the\x20de\
    scription\x20of\x20an\x20exclusion.\n\n\x0c\n\x05\x06\0\x02\x06\x01\x12\
    \x03I\x06\x12\n\x0c\n\x05\x06\0\x02\x06\x02\x12\x03I\x13&\n\x0c\n\x05\
    \x06\0\x02\x06\x03\x12\x03I1=\n\x0c\n\x05\x06\0\x02\x06\x04\x12\x03J\x04\
    F\n\x0f\n\x08\x06\0\x02\x06\x04\xe7\x07\0\x12\x03J\x04F\n\x10\n\t\x06\0\
    \x02\x06\x04\xe7\x07\0\x02\x12\x03J\x0b\x1c\n\x11\n\n\x06\0\x02\x06\x04\
    \xe7\x07\0\x02\0\x12\x03J\x0b\x1c\n\x12\n\x0b\x06\0\x02\x06\x04\xe7\x07\
    \0\x02\0\x01\x12\x03J\x0c\x1b\n\x10\n\t\x06\0\x02\x06\x04\xe7\x07\0\x08\
    \x12\x03J\x1fE\n\xb7\x01\n\x04\x06\0\x02\x07\x12\x04P\x02R\x03\x1a\xa8\
    \x01\x20Creates\x20a\x20new\x20exclusion\x20in\x20a\x20specified\x20pare\
    nt\x20resource.\n\x20Only\x20log\x20entries\x20belonging\x20to\x20that\
    \x20resource\x20can\x20be\x20excluded.\n\x20You\x20can\x20have\x20up\x20\
    to\x2010\x20exclusions\x20in\x20a\x20resource.\n\n\x0c\n\x05\x06\0\x02\
    \x07\x01\x12\x03P\x06\x15\n\x0c\n\x05\x06\0\x02\x07\x02\x12\x03P\x16,\n\
    \x0c\n\x05\x06\0\x02\x07\x03\x12\x03P7C\n\x0c\n\x05\x06\0\x02\x07\x04\
    \x12\x03Q\x04Y\n\x0f\n\x08\x06\0\x02\x07\x04\xe7\x07\0\x12\x03Q\x04Y\n\
    \x10\n\t\x06\0\x02\x07\x04\xe7\x07\0\x02\x12\x03Q\x0b\x1c\n\x11\n\n\x06\
    \0\x02\x07\x04\xe7\x07\0\x02\0\x12\x03Q\x0b\x1c\n\x12\n\x0b\x06\0\x02\
    \x07\x04\xe7\x07\0\x02\0\x01\x12\x03Q\x0c\x1b\n\x10\n\t\x06\0\x02\x07\
    \x04\xe7\x07\0\x08\x12\x03Q\x1fX\nH\n\x04\x06\0\x02\x08\x12\x04U\x02W\
    \x03\x1a:\x20Changes\x20one\x20or\x20more\x20properties\x20of\x20an\x20e\
    xisting\x20exclusion.\n\n\x0c\n\x05\x06\0\x02\x08\x01\x12\x03U\x06\x15\n\
    \x0c\n\x05\x06\0\x02\x08\x02\x12\x03U\x16,\n\x0c\n\x05\x06\0\x02\x08\x03\
    \x12\x03U7C\n\x0c\n\x05\x06\0\x02\x08\x04\x12\x03V\x04Z\n\x0f\n\x08\x06\
    \0\x02\x08\x04\xe7\x07\0\x12\x03V\x04Z\n\x10\n\t\x06\0\x02\x08\x04\xe7\
    \x07\0\x02\x12\x03V\x0b\x1c\n\x11\n\n\x06\0\x02\x08\x04\xe7\x07\0\x02\0\
    \x12\x03V\x0b\x1c\n\x12\n\x0b\x06\0\x02\x08\x04\xe7\x07\0\x02\0\x01\x12\
    \x03V\x0c\x1b\n\x10\n\t\x06\0\x02\x08\x04\xe7\x07\0\x08\x12\x03V\x1fY\n%\
    \n\x04\x06\0\x02\t\x12\x04Z\x02\\\x03\x1a\x17\x20Deletes\x20an\x20exclus\
    ion.\n\n\x0c\n\x05\x06\0\x02\t\x01\x12\x03Z\x06\x15\n\x0c\n\x05\x06\0\
    \x02\t\x02\x12\x03Z\x16,\n\x0c\n\x05\x06\0\x02\t\x03\x12\x03Z7L\n\x0c\n\
    \x05\x06\0\x02\t\x04\x12\x03[\x04I\n\x0f\n\x08\x06\0\x02\t\x04\xe7\x07\0\
    \x12\x03[\x04I\n\x10\n\t\x06\0\x02\t\x04\xe7\x07\0\x02\x12\x03[\x0b\x1c\
    \n\x11\n\n\x06\0\x02\t\x04\xe7\x07\0\x02\0\x12\x03[\x0b\x1c\n\x12\n\x0b\
    \x06\0\x02\t\x04\xe7\x07\0\x02\0\x01\x12\x03[\x0c\x1b\n\x10\n\t\x06\0\
    \x02\t\x04\xe7\x07\0\x08\x12\x03[\x1fH\n\xc7\x02\n\x02\x04\0\x12\x05d\0\
    \xb6\x01\x01\x1a\xb9\x02\x20Describes\x20a\x20sink\x20used\x20to\x20expo\
    rt\x20log\x20entries\x20to\x20one\x20of\x20the\x20following\n\x20destina\
    tions\x20in\x20any\x20project:\x20a\x20Cloud\x20Storage\x20bucket,\x20a\
    \x20BigQuery\x20dataset,\x20or\x20a\n\x20Cloud\x20Pub/Sub\x20topic.\x20\
    \x20A\x20logs\x20filter\x20controls\x20which\x20log\x20entries\x20are\n\
    \x20exported.\x20The\x20sink\x20must\x20be\x20created\x20within\x20a\x20\
    project,\x20organization,\x20billing\n\x20account,\x20or\x20folder.\n\n\
    \n\n\x03\x04\0\x01\x12\x03d\x08\x0f\n\xbb\x01\n\x04\x04\0\x04\0\x12\x04h\
    \x02q\x03\x1a\xac\x01\x20Available\x20log\x20entry\x20formats.\x20Log\
    \x20entries\x20can\x20be\x20written\x20to\x20Stackdriver\n\x20Logging\
    \x20in\x20either\x20format\x20and\x20can\x20be\x20exported\x20in\x20eith\
    er\x20format.\n\x20Version\x202\x20is\x20the\x20preferred\x20format.\n\n\
    \x0c\n\x05\x04\0\x04\0\x01\x12\x03h\x07\x14\nG\n\x06\x04\0\x04\0\x02\0\
    \x12\x03j\x04#\x1a8\x20An\x20unspecified\x20format\x20version\x20that\
    \x20will\x20default\x20to\x20V2.\n\n\x0e\n\x07\x04\0\x04\0\x02\0\x01\x12\
    \x03j\x04\x1e\n\x0e\n\x07\x04\0\x04\0\x02\0\x02\x12\x03j!\"\n-\n\x06\x04\
    \0\x04\0\x02\x01\x12\x03m\x04\x0b\x1a\x1e\x20`LogEntry`\x20version\x202\
    \x20format.\n\n\x0e\n\x07\x04\0\x04\0\x02\x01\x01\x12\x03m\x04\x06\n\x0e\
    \n\x07\x04\0\x04\0\x02\x01\x02\x12\x03m\t\n\n-\n\x06\x04\0\x04\0\x02\x02\
    \x12\x03p\x04\x0b\x1a\x1e\x20`LogEntry`\x20version\x201\x20format.\n\n\
    \x0e\n\x07\x04\0\x04\0\x02\x02\x01\x12\x03p\x04\x06\n\x0e\n\x07\x04\0\
    \x04\0\x02\x02\x02\x12\x03p\t\n\n\xb6\x02\n\x04\x04\0\x02\0\x12\x03x\x02\
    \x12\x1a\xa8\x02\x20Required.\x20The\x20client-assigned\x20sink\x20ident\
    ifier,\x20unique\x20within\x20the\n\x20project.\x20Example:\x20`\"my-sys\
    log-errors-to-pubsub\"`.\x20\x20Sink\x20identifiers\x20are\n\x20limited\
    \x20to\x20100\x20characters\x20and\x20can\x20include\x20only\x20the\x20f\
    ollowing\x20characters:\n\x20upper\x20and\x20lower-case\x20alphanumeric\
    \x20characters,\x20underscores,\x20hyphens,\x20and\n\x20periods.\n\n\r\n\
    \x05\x04\0\x02\0\x04\x12\x04x\x02q\x03\n\x0c\n\x05\x04\0\x02\0\x05\x12\
    \x03x\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03x\t\r\n\x0c\n\x05\x04\0\
    \x02\0\x03\x12\x03x\x10\x11\n\xe7\x03\n\x04\x04\0\x02\x01\x12\x04\x84\
    \x01\x02\x19\x1a\xd8\x03\x20Required.\x20The\x20export\x20destination:\n\
    \n\x20\x20\x20\x20\x20\"storage.googleapis.com/[GCS_BUCKET]\"\n\x20\x20\
    \x20\x20\x20\"bigquery.googleapis.com/projects/[PROJECT_ID]/datasets/[DA\
    TASET]\"\n\x20\x20\x20\x20\x20\"pubsub.googleapis.com/projects/[PROJECT_\
    ID]/topics/[TOPIC_ID]\"\n\n\x20The\x20sink's\x20`writer_identity`,\x20se\
    t\x20when\x20the\x20sink\x20is\x20created,\x20must\n\x20have\x20permissi\
    on\x20to\x20write\x20to\x20the\x20destination\x20or\x20else\x20the\x20lo\
    g\n\x20entries\x20are\x20not\x20exported.\x20\x20For\x20more\x20informat\
    ion,\x20see\n\x20[Exporting\x20Logs\x20With\x20Sinks](/logging/docs/api/\
    tasks/exporting-logs).\n\n\x0e\n\x05\x04\0\x02\x01\x04\x12\x05\x84\x01\
    \x02x\x12\n\r\n\x05\x04\0\x02\x01\x05\x12\x04\x84\x01\x02\x08\n\r\n\x05\
    \x04\0\x02\x01\x01\x12\x04\x84\x01\t\x14\n\r\n\x05\x04\0\x02\x01\x03\x12\
    \x04\x84\x01\x17\x18\n\xa0\x02\n\x04\x04\0\x02\x02\x12\x04\x8c\x01\x02\
    \x14\x1a\x91\x02\x20Optional.\n\x20An\x20[advanced\x20logs\x20filter](/l\
    ogging/docs/view/advanced_filters).\x20\x20The\x20only\n\x20exported\x20\
    log\x20entries\x20are\x20those\x20that\x20are\x20in\x20the\x20resource\
    \x20owning\x20the\x20sink\x20and\n\x20that\x20match\x20the\x20filter.\
    \x20\x20For\x20example:\n\n\x20\x20\x20\x20\x20logName=\"projects/[PROJE\
    CT_ID]/logs/[LOG_ID]\"\x20AND\x20severity>=ERROR\n\n\x0f\n\x05\x04\0\x02\
    \x02\x04\x12\x06\x8c\x01\x02\x84\x01\x19\n\r\n\x05\x04\0\x02\x02\x05\x12\
    \x04\x8c\x01\x02\x08\n\r\n\x05\x04\0\x02\x02\x01\x12\x04\x8c\x01\t\x0f\n\
    \r\n\x05\x04\0\x02\x02\x03\x12\x04\x8c\x01\x12\x13\n\x98\x01\n\x04\x04\0\
    \x02\x03\x12\x04\x90\x01\x02*\x1a\x89\x01\x20Deprecated.\x20The\x20log\
    \x20entry\x20format\x20to\x20use\x20for\x20this\x20sink's\x20exported\
    \x20log\n\x20entries.\x20\x20The\x20v2\x20format\x20is\x20used\x20by\x20\
    default\x20and\x20cannot\x20be\x20changed.\n\n\x0f\n\x05\x04\0\x02\x03\
    \x04\x12\x06\x90\x01\x02\x8c\x01\x14\n\r\n\x05\x04\0\x02\x03\x06\x12\x04\
    \x90\x01\x02\x0f\n\r\n\x05\x04\0\x02\x03\x01\x12\x04\x90\x01\x10%\n\r\n\
    \x05\x04\0\x02\x03\x03\x12\x04\x90\x01()\n\xa9\x06\n\x04\x04\0\x02\x04\
    \x12\x04\xa0\x01\x02\x1d\x1a\x9a\x06\x20Output\x20only.\x20An\x20IAM\x20\
    identity&mdash;a\x20service\x20account\x20or\x20group&mdash;under\n\x20w\
    hich\x20Stackdriver\x20Logging\x20writes\x20the\x20exported\x20log\x20en\
    tries\x20to\x20the\x20sink's\n\x20destination.\x20\x20This\x20field\x20i\
    s\x20set\x20by\n\x20[sinks.create](/logging/docs/api/reference/rest/v2/p\
    rojects.sinks/create)\n\x20and\n\x20[sinks.update](/logging/docs/api/ref\
    erence/rest/v2/projects.sinks/update),\n\x20based\x20on\x20the\x20settin\
    g\x20of\x20`unique_writer_identity`\x20in\x20those\x20methods.\n\n\x20Un\
    til\x20you\x20grant\x20this\x20identity\x20write-access\x20to\x20the\x20\
    destination,\x20log\x20entry\n\x20exports\x20from\x20this\x20sink\x20wil\
    l\x20fail.\x20For\x20more\x20information,\n\x20see\x20[Granting\x20acces\
    s\x20for\x20a\n\x20resource](/iam/docs/granting-roles-to-service-account\
    s#granting_access_to_a_service_account_for_a_resource).\n\x20Consult\x20\
    the\x20destination\x20service's\x20documentation\x20to\x20determine\x20t\
    he\n\x20appropriate\x20IAM\x20roles\x20to\x20assign\x20to\x20the\x20iden\
    tity.\n\n\x0f\n\x05\x04\0\x02\x04\x04\x12\x06\xa0\x01\x02\x90\x01*\n\r\n\
    \x05\x04\0\x02\x04\x05\x12\x04\xa0\x01\x02\x08\n\r\n\x05\x04\0\x02\x04\
    \x01\x12\x04\xa0\x01\t\x18\n\r\n\x05\x04\0\x02\x04\x03\x12\x04\xa0\x01\
    \x1b\x1c\n\xd6\x06\n\x04\x04\0\x02\x05\x12\x04\xaf\x01\x02\x1c\x1a\xc7\
    \x06\x20Optional.\x20This\x20field\x20applies\x20only\x20to\x20sinks\x20\
    owned\x20by\x20organizations\x20and\n\x20folders.\x20If\x20the\x20field\
    \x20is\x20false,\x20the\x20default,\x20only\x20the\x20logs\x20owned\x20b\
    y\x20the\n\x20sink's\x20parent\x20resource\x20are\x20available\x20for\
    \x20export.\x20If\x20the\x20field\x20is\x20true,\x20then\n\x20logs\x20fr\
    om\x20all\x20the\x20projects,\x20folders,\x20and\x20billing\x20accounts\
    \x20contained\x20in\x20the\n\x20sink's\x20parent\x20resource\x20are\x20a\
    lso\x20available\x20for\x20export.\x20Whether\x20a\x20particular\n\x20lo\
    g\x20entry\x20from\x20the\x20children\x20is\x20exported\x20depends\x20on\
    \x20the\x20sink's\x20filter\n\x20expression.\x20For\x20example,\x20if\
    \x20this\x20field\x20is\x20true,\x20then\x20the\x20filter\n\x20`resource\
    .type=gce_instance`\x20would\x20export\x20all\x20Compute\x20Engine\x20VM\
    \x20instance\n\x20log\x20entries\x20from\x20all\x20projects\x20in\x20the\
    \x20sink's\x20parent.\x20To\x20only\x20export\x20entries\n\x20from\x20ce\
    rtain\x20child\x20projects,\x20filter\x20on\x20the\x20project\x20part\
    \x20of\x20the\x20log\x20name:\n\n\x20\x20\x20\x20\x20logName:(\"projects\
    /test-project1/\"\x20OR\x20\"projects/test-project2/\")\x20AND\n\x20\x20\
    \x20\x20\x20resource.type=gce_instance\n\n\x0f\n\x05\x04\0\x02\x05\x04\
    \x12\x06\xaf\x01\x02\xa0\x01\x1d\n\r\n\x05\x04\0\x02\x05\x05\x12\x04\xaf\
    \x01\x02\x06\n\r\n\x05\x04\0\x02\x05\x01\x12\x04\xaf\x01\x07\x17\n\r\n\
    \x05\x04\0\x02\x05\x03\x12\x04\xaf\x01\x1a\x1b\nR\n\x04\x04\0\x02\x06\
    \x12\x04\xb2\x01\x02,\x1aD\x20Deprecated.\x20This\x20field\x20is\x20igno\
    red\x20when\x20creating\x20or\x20updating\x20sinks.\n\n\x0f\n\x05\x04\0\
    \x02\x06\x04\x12\x06\xb2\x01\x02\xaf\x01\x1c\n\r\n\x05\x04\0\x02\x06\x06\
    \x12\x04\xb2\x01\x02\x1b\n\r\n\x05\x04\0\x02\x06\x01\x12\x04\xb2\x01\x1c\
    &\n\r\n\x05\x04\0\x02\x06\x03\x12\x04\xb2\x01)+\nR\n\x04\x04\0\x02\x07\
    \x12\x04\xb5\x01\x02*\x1aD\x20Deprecated.\x20This\x20field\x20is\x20igno\
    red\x20when\x20creating\x20or\x20updating\x20sinks.\n\n\x0f\n\x05\x04\0\
    \x02\x07\x04\x12\x06\xb5\x01\x02\xb2\x01,\n\r\n\x05\x04\0\x02\x07\x06\
    \x12\x04\xb5\x01\x02\x1b\n\r\n\x05\x04\0\x02\x07\x01\x12\x04\xb5\x01\x1c\
    $\n\r\n\x05\x04\0\x02\x07\x03\x12\x04\xb5\x01')\n.\n\x02\x04\x01\x12\x06\
    \xb9\x01\0\xcc\x01\x01\x1a\x20\x20The\x20parameters\x20to\x20`ListSinks`\
    .\n\n\x0b\n\x03\x04\x01\x01\x12\x04\xb9\x01\x08\x18\n\xd8\x01\n\x04\x04\
    \x01\x02\0\x12\x04\xc0\x01\x02\x14\x1a\xc9\x01\x20Required.\x20The\x20pa\
    rent\x20resource\x20whose\x20sinks\x20are\x20to\x20be\x20listed:\n\n\x20\
    \x20\x20\x20\x20\"projects/[PROJECT_ID]\"\n\x20\x20\x20\x20\x20\"organiz\
    ations/[ORGANIZATION_ID]\"\n\x20\x20\x20\x20\x20\"billingAccounts/[BILLI\
    NG_ACCOUNT_ID]\"\n\x20\x20\x20\x20\x20\"folders/[FOLDER_ID]\"\n\n\x0f\n\
    \x05\x04\x01\x02\0\x04\x12\x06\xc0\x01\x02\xb9\x01\x1a\n\r\n\x05\x04\x01\
    \x02\0\x05\x12\x04\xc0\x01\x02\x08\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\
    \xc0\x01\t\x0f\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xc0\x01\x12\x13\n\xa1\
    \x02\n\x04\x04\x01\x02\x01\x12\x04\xc6\x01\x02\x18\x1a\x92\x02\x20Option\
    al.\x20If\x20present,\x20then\x20retrieve\x20the\x20next\x20batch\x20of\
    \x20results\x20from\x20the\n\x20preceding\x20call\x20to\x20this\x20metho\
    d.\x20\x20`pageToken`\x20must\x20be\x20the\x20value\x20of\n\x20`nextPage\
    Token`\x20from\x20the\x20previous\x20response.\x20\x20The\x20values\x20o\
    f\x20other\x20method\n\x20parameters\x20should\x20be\x20identical\x20to\
    \x20those\x20in\x20the\x20previous\x20call.\n\n\x0f\n\x05\x04\x01\x02\
    \x01\x04\x12\x06\xc6\x01\x02\xc0\x01\x14\n\r\n\x05\x04\x01\x02\x01\x05\
    \x12\x04\xc6\x01\x02\x08\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\xc6\x01\t\
    \x13\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\xc6\x01\x16\x17\n\xd9\x01\n\
    \x04\x04\x01\x02\x02\x12\x04\xcb\x01\x02\x16\x1a\xca\x01\x20Optional.\
    \x20The\x20maximum\x20number\x20of\x20results\x20to\x20return\x20from\
    \x20this\x20request.\n\x20Non-positive\x20values\x20are\x20ignored.\x20\
    \x20The\x20presence\x20of\x20`nextPageToken`\x20in\x20the\n\x20response\
    \x20indicates\x20that\x20more\x20results\x20might\x20be\x20available.\n\
    \n\x0f\n\x05\x04\x01\x02\x02\x04\x12\x06\xcb\x01\x02\xc6\x01\x18\n\r\n\
    \x05\x04\x01\x02\x02\x05\x12\x04\xcb\x01\x02\x07\n\r\n\x05\x04\x01\x02\
    \x02\x01\x12\x04\xcb\x01\x08\x11\n\r\n\x05\x04\x01\x02\x02\x03\x12\x04\
    \xcb\x01\x14\x15\n1\n\x02\x04\x02\x12\x06\xcf\x01\0\xd7\x01\x01\x1a#\x20\
    Result\x20returned\x20from\x20`ListSinks`.\n\n\x0b\n\x03\x04\x02\x01\x12\
    \x04\xcf\x01\x08\x19\n\x20\n\x04\x04\x02\x02\0\x12\x04\xd1\x01\x02\x1d\
    \x1a\x12\x20A\x20list\x20of\x20sinks.\n\n\r\n\x05\x04\x02\x02\0\x04\x12\
    \x04\xd1\x01\x02\n\n\r\n\x05\x04\x02\x02\0\x06\x12\x04\xd1\x01\x0b\x12\n\
    \r\n\x05\x04\x02\x02\0\x01\x12\x04\xd1\x01\x13\x18\n\r\n\x05\x04\x02\x02\
    \0\x03\x12\x04\xd1\x01\x1b\x1c\n\xe0\x01\n\x04\x04\x02\x02\x01\x12\x04\
    \xd6\x01\x02\x1d\x1a\xd1\x01\x20If\x20there\x20might\x20be\x20more\x20re\
    sults\x20than\x20appear\x20in\x20this\x20response,\x20then\n\x20`nextPag\
    eToken`\x20is\x20included.\x20\x20To\x20get\x20the\x20next\x20set\x20of\
    \x20results,\x20call\x20the\x20same\n\x20method\x20again\x20using\x20the\
    \x20value\x20of\x20`nextPageToken`\x20as\x20`pageToken`.\n\n\x0f\n\x05\
    \x04\x02\x02\x01\x04\x12\x06\xd6\x01\x02\xd1\x01\x1d\n\r\n\x05\x04\x02\
    \x02\x01\x05\x12\x04\xd6\x01\x02\x08\n\r\n\x05\x04\x02\x02\x01\x01\x12\
    \x04\xd6\x01\t\x18\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\xd6\x01\x1b\x1c\
    \n,\n\x02\x04\x03\x12\x06\xda\x01\0\xe4\x01\x01\x1a\x1e\x20The\x20parame\
    ters\x20to\x20`GetSink`.\n\n\x0b\n\x03\x04\x03\x01\x12\x04\xda\x01\x08\
    \x16\n\xbd\x02\n\x04\x04\x03\x02\0\x12\x04\xe3\x01\x02\x17\x1a\xae\x02\
    \x20Required.\x20The\x20resource\x20name\x20of\x20the\x20sink:\n\n\x20\
    \x20\x20\x20\x20\"projects/[PROJECT_ID]/sinks/[SINK_ID]\"\n\x20\x20\x20\
    \x20\x20\"organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]\"\n\x20\x20\
    \x20\x20\x20\"billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]\"\n\
    \x20\x20\x20\x20\x20\"folders/[FOLDER_ID]/sinks/[SINK_ID]\"\n\n\x20Examp\
    le:\x20`\"projects/my-project-id/sinks/my-sink-id\"`.\n\n\x0f\n\x05\x04\
    \x03\x02\0\x04\x12\x06\xe3\x01\x02\xda\x01\x18\n\r\n\x05\x04\x03\x02\0\
    \x05\x12\x04\xe3\x01\x02\x08\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xe3\x01\
    \t\x12\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xe3\x01\x15\x16\n/\n\x02\x04\
    \x04\x12\x06\xe7\x01\0\x82\x02\x01\x1a!\x20The\x20parameters\x20to\x20`C\
    reateSink`.\n\n\x0b\n\x03\x04\x04\x01\x12\x04\xe7\x01\x08\x19\n\x9a\x02\
    \n\x04\x04\x04\x02\0\x12\x04\xf0\x01\x02\x14\x1a\x8b\x02\x20Required.\
    \x20The\x20resource\x20in\x20which\x20to\x20create\x20the\x20sink:\n\n\
    \x20\x20\x20\x20\x20\"projects/[PROJECT_ID]\"\n\x20\x20\x20\x20\x20\"org\
    anizations/[ORGANIZATION_ID]\"\n\x20\x20\x20\x20\x20\"billingAccounts/[B\
    ILLING_ACCOUNT_ID]\"\n\x20\x20\x20\x20\x20\"folders/[FOLDER_ID]\"\n\n\
    \x20Examples:\x20`\"projects/my-logging-project\"`,\x20`\"organizations/\
    123456789\"`.\n\n\x0f\n\x05\x04\x04\x02\0\x04\x12\x06\xf0\x01\x02\xe7\
    \x01\x1b\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\xf0\x01\x02\x08\n\r\n\x05\
    \x04\x04\x02\0\x01\x12\x04\xf0\x01\t\x0f\n\r\n\x05\x04\x04\x02\0\x03\x12\
    \x04\xf0\x01\x12\x13\np\n\x04\x04\x04\x02\x01\x12\x04\xf4\x01\x02\x13\
    \x1ab\x20Required.\x20The\x20new\x20sink,\x20whose\x20`name`\x20paramete\
    r\x20is\x20a\x20sink\x20identifier\x20that\n\x20is\x20not\x20already\x20\
    in\x20use.\n\n\x0f\n\x05\x04\x04\x02\x01\x04\x12\x06\xf4\x01\x02\xf0\x01\
    \x14\n\r\n\x05\x04\x04\x02\x01\x06\x12\x04\xf4\x01\x02\t\n\r\n\x05\x04\
    \x04\x02\x01\x01\x12\x04\xf4\x01\n\x0e\n\r\n\x05\x04\x04\x02\x01\x03\x12\
    \x04\xf4\x01\x11\x12\n\xe1\x05\n\x04\x04\x04\x02\x02\x12\x04\x81\x02\x02\
    \"\x1a\xd2\x05\x20Optional.\x20Determines\x20the\x20kind\x20of\x20IAM\
    \x20identity\x20returned\x20as\x20`writer_identity`\n\x20in\x20the\x20ne\
    w\x20sink.\x20\x20If\x20this\x20value\x20is\x20omitted\x20or\x20set\x20t\
    o\x20false,\x20and\x20if\x20the\n\x20sink's\x20parent\x20is\x20a\x20proj\
    ect,\x20then\x20the\x20value\x20returned\x20as\x20`writer_identity`\x20i\
    s\n\x20the\x20same\x20group\x20or\x20service\x20account\x20used\x20by\
    \x20Stackdriver\x20Logging\x20before\x20the\n\x20addition\x20of\x20write\
    r\x20identities\x20to\x20this\x20API.\x20The\x20sink's\x20destination\
    \x20must\x20be\n\x20in\x20the\x20same\x20project\x20as\x20the\x20sink\
    \x20itself.\n\n\x20If\x20this\x20field\x20is\x20set\x20to\x20true,\x20or\
    \x20if\x20the\x20sink\x20is\x20owned\x20by\x20a\x20non-project\n\x20reso\
    urce\x20such\x20as\x20an\x20organization,\x20then\x20the\x20value\x20of\
    \x20`writer_identity`\x20will\n\x20be\x20a\x20unique\x20service\x20accou\
    nt\x20used\x20only\x20for\x20exports\x20from\x20the\x20new\x20sink.\x20\
    \x20For\n\x20more\x20information,\x20see\x20`writer_identity`\x20in\x20[\
    LogSink][google.logging.v2.LogSink].\n\n\x0f\n\x05\x04\x04\x02\x02\x04\
    \x12\x06\x81\x02\x02\xf4\x01\x13\n\r\n\x05\x04\x04\x02\x02\x05\x12\x04\
    \x81\x02\x02\x06\n\r\n\x05\x04\x04\x02\x02\x01\x12\x04\x81\x02\x07\x1d\n\
    \r\n\x05\x04\x04\x02\x02\x03\x12\x04\x81\x02\x20!\n/\n\x02\x04\x05\x12\
    \x06\x85\x02\0\xb2\x02\x01\x1a!\x20The\x20parameters\x20to\x20`UpdateSin\
    k`.\n\n\x0b\n\x03\x04\x05\x01\x12\x04\x85\x02\x08\x19\n\x84\x03\n\x04\
    \x04\x05\x02\0\x12\x04\x8f\x02\x02\x17\x1a\xf5\x02\x20Required.\x20The\
    \x20full\x20resource\x20name\x20of\x20the\x20sink\x20to\x20update,\x20in\
    cluding\x20the\n\x20parent\x20resource\x20and\x20the\x20sink\x20identifi\
    er:\n\n\x20\x20\x20\x20\x20\"projects/[PROJECT_ID]/sinks/[SINK_ID]\"\n\
    \x20\x20\x20\x20\x20\"organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]\"\
    \n\x20\x20\x20\x20\x20\"billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK\
    _ID]\"\n\x20\x20\x20\x20\x20\"folders/[FOLDER_ID]/sinks/[SINK_ID]\"\n\n\
    \x20Example:\x20`\"projects/my-project-id/sinks/my-sink-id\"`.\n\n\x0f\n\
    \x05\x04\x05\x02\0\x04\x12\x06\x8f\x02\x02\x85\x02\x1b\n\r\n\x05\x04\x05\
    \x02\0\x05\x12\x04\x8f\x02\x02\x08\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\
    \x8f\x02\t\x12\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\x8f\x02\x15\x16\ns\n\
    \x04\x04\x05\x02\x01\x12\x04\x93\x02\x02\x13\x1ae\x20Required.\x20The\
    \x20updated\x20sink,\x20whose\x20name\x20is\x20the\x20same\x20identifier\
    \x20that\x20appears\n\x20as\x20part\x20of\x20`sink_name`.\n\n\x0f\n\x05\
    \x04\x05\x02\x01\x04\x12\x06\x93\x02\x02\x8f\x02\x17\n\r\n\x05\x04\x05\
    \x02\x01\x06\x12\x04\x93\x02\x02\t\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\
    \x93\x02\n\x0e\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\x93\x02\x11\x12\n\
    \x9b\x05\n\x04\x04\x05\x02\x02\x12\x04\xa1\x02\x02\"\x1a\x8c\x05\x20Opti\
    onal.\x20See\n\x20[sinks.create](/logging/docs/api/reference/rest/v2/pro\
    jects.sinks/create)\n\x20for\x20a\x20description\x20of\x20this\x20field.\
    \x20\x20When\x20updating\x20a\x20sink,\x20the\x20effect\x20of\x20this\n\
    \x20field\x20on\x20the\x20value\x20of\x20`writer_identity`\x20in\x20the\
    \x20updated\x20sink\x20depends\x20on\x20both\n\x20the\x20old\x20and\x20n\
    ew\x20values\x20of\x20this\x20field:\n\n\x20+\x20\x20\x20If\x20the\x20ol\
    d\x20and\x20new\x20values\x20of\x20this\x20field\x20are\x20both\x20false\
    \x20or\x20both\x20true,\n\x20\x20\x20\x20\x20then\x20there\x20is\x20no\
    \x20change\x20to\x20the\x20sink's\x20`writer_identity`.\n\x20+\x20\x20\
    \x20If\x20the\x20old\x20value\x20is\x20false\x20and\x20the\x20new\x20val\
    ue\x20is\x20true,\x20then\n\x20\x20\x20\x20\x20`writer_identity`\x20is\
    \x20changed\x20to\x20a\x20unique\x20service\x20account.\n\x20+\x20\x20\
    \x20It\x20is\x20an\x20error\x20if\x20the\x20old\x20value\x20is\x20true\
    \x20and\x20the\x20new\x20value\x20is\n\x20\x20\x20\x20\x20set\x20to\x20f\
    alse\x20or\x20defaulted\x20to\x20false.\n\n\x0f\n\x05\x04\x05\x02\x02\
    \x04\x12\x06\xa1\x02\x02\x93\x02\x13\n\r\n\x05\x04\x05\x02\x02\x05\x12\
    \x04\xa1\x02\x02\x06\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\xa1\x02\x07\
    \x1d\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\xa1\x02\x20!\n\x87\x05\n\x04\
    \x04\x05\x02\x03\x12\x04\xb1\x02\x02,\x1a\xf8\x04\x20Optional.\x20Field\
    \x20mask\x20that\x20specifies\x20the\x20fields\x20in\x20`sink`\x20that\
    \x20need\n\x20an\x20update.\x20A\x20sink\x20field\x20will\x20be\x20overw\
    ritten\x20if,\x20and\x20only\x20if,\x20it\x20is\n\x20in\x20the\x20update\
    \x20mask.\x20\x20`name`\x20and\x20output\x20only\x20fields\x20cannot\x20\
    be\x20updated.\n\n\x20An\x20empty\x20updateMask\x20is\x20temporarily\x20\
    treated\x20as\x20using\x20the\x20following\x20mask\n\x20for\x20backwards\
    \x20compatibility\x20purposes:\n\x20\x20\x20destination,filter,includeCh\
    ildren\n\x20At\x20some\x20point\x20in\x20the\x20future,\x20behavior\x20w\
    ill\x20be\x20removed\x20and\x20specifying\x20an\n\x20empty\x20updateMask\
    \x20will\x20be\x20an\x20error.\n\n\x20For\x20a\x20detailed\x20`FieldMask\
    `\x20definition,\x20see\n\x20https://developers.google.com/protocol-buff\
    ers/docs/reference/google.protobuf#fieldmask\n\n\x20Example:\x20`updateM\
    ask=filter`.\n\n\x0f\n\x05\x04\x05\x02\x03\x04\x12\x06\xb1\x02\x02\xa1\
    \x02\"\n\r\n\x05\x04\x05\x02\x03\x06\x12\x04\xb1\x02\x02\x1b\n\r\n\x05\
    \x04\x05\x02\x03\x01\x12\x04\xb1\x02\x1c'\n\r\n\x05\x04\x05\x02\x03\x03\
    \x12\x04\xb1\x02*+\n/\n\x02\x04\x06\x12\x06\xb5\x02\0\xc0\x02\x01\x1a!\
    \x20The\x20parameters\x20to\x20`DeleteSink`.\n\n\x0b\n\x03\x04\x06\x01\
    \x12\x04\xb5\x02\x08\x19\n\x84\x03\n\x04\x04\x06\x02\0\x12\x04\xbf\x02\
    \x02\x17\x1a\xf5\x02\x20Required.\x20The\x20full\x20resource\x20name\x20\
    of\x20the\x20sink\x20to\x20delete,\x20including\x20the\n\x20parent\x20re\
    source\x20and\x20the\x20sink\x20identifier:\n\n\x20\x20\x20\x20\x20\"pro\
    jects/[PROJECT_ID]/sinks/[SINK_ID]\"\n\x20\x20\x20\x20\x20\"organization\
    s/[ORGANIZATION_ID]/sinks/[SINK_ID]\"\n\x20\x20\x20\x20\x20\"billingAcco\
    unts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]\"\n\x20\x20\x20\x20\x20\"folde\
    rs/[FOLDER_ID]/sinks/[SINK_ID]\"\n\n\x20Example:\x20`\"projects/my-proje\
    ct-id/sinks/my-sink-id\"`.\n\n\x0f\n\x05\x04\x06\x02\0\x04\x12\x06\xbf\
    \x02\x02\xb5\x02\x1b\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\xbf\x02\x02\x08\
    \n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xbf\x02\t\x12\n\r\n\x05\x04\x06\x02\
    \0\x03\x12\x04\xbf\x02\x15\x16\n\x8c\x03\n\x02\x04\x07\x12\x06\xc8\x02\0\
    \xe1\x02\x01\x1a\xfd\x02\x20Specifies\x20a\x20set\x20of\x20log\x20entrie\
    s\x20that\x20are\x20not\x20to\x20be\x20stored\x20in\x20Stackdriver\n\x20\
    Logging.\x20If\x20your\x20project\x20receives\x20a\x20large\x20volume\
    \x20of\x20logs,\x20you\x20might\x20be\x20able\n\x20to\x20use\x20exclusio\
    ns\x20to\x20reduce\x20your\x20chargeable\x20logs.\x20Exclusions\x20are\
    \x20processed\n\x20after\x20log\x20sinks,\x20so\x20you\x20can\x20export\
    \x20log\x20entries\x20before\x20they\x20are\x20excluded.\n\x20Audit\x20l\
    og\x20entries\x20and\x20log\x20entries\x20from\x20Amazon\x20Web\x20Servi\
    ces\x20are\x20never\n\x20excluded.\n\n\x0b\n\x03\x04\x07\x01\x12\x04\xc8\
    \x02\x08\x14\n\xd2\x01\n\x04\x04\x07\x02\0\x12\x04\xcc\x02\x02\x12\x1a\
    \xc3\x01\x20Required.\x20A\x20client-assigned\x20identifier,\x20such\x20\
    as\n\x20`\"load-balancer-exclusion\"`.\x20Identifiers\x20are\x20limited\
    \x20to\x20100\x20characters\x20and\n\x20can\x20include\x20only\x20letter\
    s,\x20digits,\x20underscores,\x20hyphens,\x20and\x20periods.\n\n\x0f\n\
    \x05\x04\x07\x02\0\x04\x12\x06\xcc\x02\x02\xc8\x02\x16\n\r\n\x05\x04\x07\
    \x02\0\x05\x12\x04\xcc\x02\x02\x08\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\
    \xcc\x02\t\r\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xcc\x02\x10\x11\n:\n\
    \x04\x04\x07\x02\x01\x12\x04\xcf\x02\x02\x19\x1a,\x20Optional.\x20A\x20d\
    escription\x20of\x20this\x20exclusion.\n\n\x0f\n\x05\x04\x07\x02\x01\x04\
    \x12\x06\xcf\x02\x02\xcc\x02\x12\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\
    \xcf\x02\x02\x08\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xcf\x02\t\x14\n\r\
    \n\x05\x04\x07\x02\x01\x03\x12\x04\xcf\x02\x17\x18\n\xc2\x03\n\x04\x04\
    \x07\x02\x02\x12\x04\xda\x02\x02\x14\x1a\xb3\x03\x20Required.\n\x20An\
    \x20[advanced\x20logs\x20filter](/logging/docs/view/advanced_filters)\n\
    \x20that\x20matches\x20the\x20log\x20entries\x20to\x20be\x20excluded.\
    \x20By\x20using\x20the\n\x20[sample\x20function](/logging/docs/view/adva\
    nced_filters#sample),\n\x20you\x20can\x20exclude\x20less\x20than\x20100%\
    \x20of\x20the\x20matching\x20log\x20entries.\n\x20For\x20example,\x20the\
    \x20following\x20filter\x20matches\x2099%\x20of\x20low-severity\x20log\n\
    \x20entries\x20from\x20load\x20balancers:\n\n\x20\x20\x20\x20\x20\"resou\
    rce.type=http_load_balancer\x20severity<ERROR\x20sample(insertId,\x200.9\
    9)\"\n\n\x0f\n\x05\x04\x07\x02\x02\x04\x12\x06\xda\x02\x02\xcf\x02\x19\n\
    \r\n\x05\x04\x07\x02\x02\x05\x12\x04\xda\x02\x02\x08\n\r\n\x05\x04\x07\
    \x02\x02\x01\x12\x04\xda\x02\t\x0f\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\
    \xda\x02\x12\x13\n\x8b\x02\n\x04\x04\x07\x02\x03\x12\x04\xe0\x02\x02\x14\
    \x1a\xfc\x01\x20Optional.\x20If\x20set\x20to\x20True,\x20then\x20this\
    \x20exclusion\x20is\x20disabled\x20and\x20it\x20does\x20not\n\x20exclude\
    \x20any\x20log\x20entries.\x20You\x20can\x20use\n\x20[exclusions.patch](\
    /logging/docs/alpha-exclusion/docs/reference/v2/rest/v2/projects.exclusi\
    ons/patch)\n\x20to\x20change\x20the\x20value\x20of\x20this\x20field.\n\n\
    \x0f\n\x05\x04\x07\x02\x03\x04\x12\x06\xe0\x02\x02\xda\x02\x14\n\r\n\x05\
    \x04\x07\x02\x03\x05\x12\x04\xe0\x02\x02\x06\n\r\n\x05\x04\x07\x02\x03\
    \x01\x12\x04\xe0\x02\x07\x0f\n\r\n\x05\x04\x07\x02\x03\x03\x12\x04\xe0\
    \x02\x12\x13\n3\n\x02\x04\x08\x12\x06\xe4\x02\0\xf7\x02\x01\x1a%\x20The\
    \x20parameters\x20to\x20`ListExclusions`.\n\n\x0b\n\x03\x04\x08\x01\x12\
    \x04\xe4\x02\x08\x1d\n\xdd\x01\n\x04\x04\x08\x02\0\x12\x04\xeb\x02\x02\
    \x14\x1a\xce\x01\x20Required.\x20The\x20parent\x20resource\x20whose\x20e\
    xclusions\x20are\x20to\x20be\x20listed.\n\n\x20\x20\x20\x20\x20\"project\
    s/[PROJECT_ID]\"\n\x20\x20\x20\x20\x20\"organizations/[ORGANIZATION_ID]\
    \"\n\x20\x20\x20\x20\x20\"billingAccounts/[BILLING_ACCOUNT_ID]\"\n\x20\
    \x20\x20\x20\x20\"folders/[FOLDER_ID]\"\n\n\x0f\n\x05\x04\x08\x02\0\x04\
    \x12\x06\xeb\x02\x02\xe4\x02\x1f\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xeb\
    \x02\x02\x08\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xeb\x02\t\x0f\n\r\n\x05\
    \x04\x08\x02\0\x03\x12\x04\xeb\x02\x12\x13\n\xa1\x02\n\x04\x04\x08\x02\
    \x01\x12\x04\xf1\x02\x02\x18\x1a\x92\x02\x20Optional.\x20If\x20present,\
    \x20then\x20retrieve\x20the\x20next\x20batch\x20of\x20results\x20from\
    \x20the\n\x20preceding\x20call\x20to\x20this\x20method.\x20\x20`pageToke\
    n`\x20must\x20be\x20the\x20value\x20of\n\x20`nextPageToken`\x20from\x20t\
    he\x20previous\x20response.\x20\x20The\x20values\x20of\x20other\x20metho\
    d\n\x20parameters\x20should\x20be\x20identical\x20to\x20those\x20in\x20t\
    he\x20previous\x20call.\n\n\x0f\n\x05\x04\x08\x02\x01\x04\x12\x06\xf1\
    \x02\x02\xeb\x02\x14\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xf1\x02\x02\
    \x08\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xf1\x02\t\x13\n\r\n\x05\x04\
    \x08\x02\x01\x03\x12\x04\xf1\x02\x16\x17\n\xd9\x01\n\x04\x04\x08\x02\x02\
    \x12\x04\xf6\x02\x02\x16\x1a\xca\x01\x20Optional.\x20The\x20maximum\x20n\
    umber\x20of\x20results\x20to\x20return\x20from\x20this\x20request.\n\x20\
    Non-positive\x20values\x20are\x20ignored.\x20\x20The\x20presence\x20of\
    \x20`nextPageToken`\x20in\x20the\n\x20response\x20indicates\x20that\x20m\
    ore\x20results\x20might\x20be\x20available.\n\n\x0f\n\x05\x04\x08\x02\
    \x02\x04\x12\x06\xf6\x02\x02\xf1\x02\x18\n\r\n\x05\x04\x08\x02\x02\x05\
    \x12\x04\xf6\x02\x02\x07\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\xf6\x02\
    \x08\x11\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\xf6\x02\x14\x15\n6\n\x02\
    \x04\t\x12\x06\xfa\x02\0\x82\x03\x01\x1a(\x20Result\x20returned\x20from\
    \x20`ListExclusions`.\n\n\x0b\n\x03\x04\t\x01\x12\x04\xfa\x02\x08\x1e\n%\
    \n\x04\x04\t\x02\0\x12\x04\xfc\x02\x02'\x1a\x17\x20A\x20list\x20of\x20ex\
    clusions.\n\n\r\n\x05\x04\t\x02\0\x04\x12\x04\xfc\x02\x02\n\n\r\n\x05\
    \x04\t\x02\0\x06\x12\x04\xfc\x02\x0b\x17\n\r\n\x05\x04\t\x02\0\x01\x12\
    \x04\xfc\x02\x18\"\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xfc\x02%&\n\xe0\x01\
    \n\x04\x04\t\x02\x01\x12\x04\x81\x03\x02\x1d\x1a\xd1\x01\x20If\x20there\
    \x20might\x20be\x20more\x20results\x20than\x20appear\x20in\x20this\x20re\
    sponse,\x20then\n\x20`nextPageToken`\x20is\x20included.\x20\x20To\x20get\
    \x20the\x20next\x20set\x20of\x20results,\x20call\x20the\x20same\n\x20met\
    hod\x20again\x20using\x20the\x20value\x20of\x20`nextPageToken`\x20as\x20\
    `pageToken`.\n\n\x0f\n\x05\x04\t\x02\x01\x04\x12\x06\x81\x03\x02\xfc\x02\
    '\n\r\n\x05\x04\t\x02\x01\x05\x12\x04\x81\x03\x02\x08\n\r\n\x05\x04\t\
    \x02\x01\x01\x12\x04\x81\x03\t\x18\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\
    \x81\x03\x1b\x1c\n1\n\x02\x04\n\x12\x06\x85\x03\0\x8f\x03\x01\x1a#\x20Th\
    e\x20parameters\x20to\x20`GetExclusion`.\n\n\x0b\n\x03\x04\n\x01\x12\x04\
    \x85\x03\x08\x1b\n\xfc\x02\n\x04\x04\n\x02\0\x12\x04\x8e\x03\x02\x12\x1a\
    \xed\x02\x20Required.\x20The\x20resource\x20name\x20of\x20an\x20existing\
    \x20exclusion:\n\n\x20\x20\x20\x20\x20\"projects/[PROJECT_ID]/exclusions\
    /[EXCLUSION_ID]\"\n\x20\x20\x20\x20\x20\"organizations/[ORGANIZATION_ID]\
    /exclusions/[EXCLUSION_ID]\"\n\x20\x20\x20\x20\x20\"billingAccounts/[BIL\
    LING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]\"\n\x20\x20\x20\x20\x20\"fold\
    ers/[FOLDER_ID]/exclusions/[EXCLUSION_ID]\"\n\n\x20Example:\x20`\"projec\
    ts/my-project-id/exclusions/my-exclusion-id\"`.\n\n\x0f\n\x05\x04\n\x02\
    \0\x04\x12\x06\x8e\x03\x02\x85\x03\x1d\n\r\n\x05\x04\n\x02\0\x05\x12\x04\
    \x8e\x03\x02\x08\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x8e\x03\t\r\n\r\n\x05\
    \x04\n\x02\0\x03\x12\x04\x8e\x03\x10\x11\n4\n\x02\x04\x0b\x12\x06\x92\
    \x03\0\xa0\x03\x01\x1a&\x20The\x20parameters\x20to\x20`CreateExclusion`.\
    \n\n\x0b\n\x03\x04\x0b\x01\x12\x04\x92\x03\x08\x1e\n\xa6\x02\n\x04\x04\
    \x0b\x02\0\x12\x04\x9b\x03\x02\x14\x1a\x97\x02\x20Required.\x20The\x20pa\
    rent\x20resource\x20in\x20which\x20to\x20create\x20the\x20exclusion:\n\n\
    \x20\x20\x20\x20\x20\"projects/[PROJECT_ID]\"\n\x20\x20\x20\x20\x20\"org\
    anizations/[ORGANIZATION_ID]\"\n\x20\x20\x20\x20\x20\"billingAccounts/[B\
    ILLING_ACCOUNT_ID]\"\n\x20\x20\x20\x20\x20\"folders/[FOLDER_ID]\"\n\n\
    \x20Examples:\x20`\"projects/my-logging-project\"`,\x20`\"organizations/\
    123456789\"`.\n\n\x0f\n\x05\x04\x0b\x02\0\x04\x12\x06\x9b\x03\x02\x92\
    \x03\x20\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\x9b\x03\x02\x08\n\r\n\x05\
    \x04\x0b\x02\0\x01\x12\x04\x9b\x03\t\x0f\n\r\n\x05\x04\x0b\x02\0\x03\x12\
    \x04\x9b\x03\x12\x13\n\x8a\x01\n\x04\x04\x0b\x02\x01\x12\x04\x9f\x03\x02\
    \x1d\x1a|\x20Required.\x20The\x20new\x20exclusion,\x20whose\x20`name`\
    \x20parameter\x20is\x20an\x20exclusion\x20name\n\x20that\x20is\x20not\
    \x20already\x20used\x20in\x20the\x20parent\x20resource.\n\n\x0f\n\x05\
    \x04\x0b\x02\x01\x04\x12\x06\x9f\x03\x02\x9b\x03\x14\n\r\n\x05\x04\x0b\
    \x02\x01\x06\x12\x04\x9f\x03\x02\x0e\n\r\n\x05\x04\x0b\x02\x01\x01\x12\
    \x04\x9f\x03\x0f\x18\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x9f\x03\x1b\
    \x1c\n4\n\x02\x04\x0c\x12\x06\xa3\x03\0\xba\x03\x01\x1a&\x20The\x20param\
    eters\x20to\x20`UpdateExclusion`.\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\xa3\
    \x03\x08\x1e\n\xfe\x02\n\x04\x04\x0c\x02\0\x12\x04\xac\x03\x02\x12\x1a\
    \xef\x02\x20Required.\x20The\x20resource\x20name\x20of\x20the\x20exclusi\
    on\x20to\x20update:\n\n\x20\x20\x20\x20\x20\"projects/[PROJECT_ID]/exclu\
    sions/[EXCLUSION_ID]\"\n\x20\x20\x20\x20\x20\"organizations/[ORGANIZATIO\
    N_ID]/exclusions/[EXCLUSION_ID]\"\n\x20\x20\x20\x20\x20\"billingAccounts\
    /[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]\"\n\x20\x20\x20\x20\x20\
    \"folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]\"\n\n\x20Example:\x20`\"\
    projects/my-project-id/exclusions/my-exclusion-id\"`.\n\n\x0f\n\x05\x04\
    \x0c\x02\0\x04\x12\x06\xac\x03\x02\xa3\x03\x20\n\r\n\x05\x04\x0c\x02\0\
    \x05\x12\x04\xac\x03\x02\x08\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xac\x03\
    \t\r\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xac\x03\x10\x11\nz\n\x04\x04\
    \x0c\x02\x01\x12\x04\xb0\x03\x02\x1d\x1al\x20Required.\x20New\x20values\
    \x20for\x20the\x20existing\x20exclusion.\x20Only\x20the\x20fields\x20spe\
    cified\n\x20in\x20`update_mask`\x20are\x20relevant.\n\n\x0f\n\x05\x04\
    \x0c\x02\x01\x04\x12\x06\xb0\x03\x02\xac\x03\x12\n\r\n\x05\x04\x0c\x02\
    \x01\x06\x12\x04\xb0\x03\x02\x0e\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\
    \xb0\x03\x0f\x18\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xb0\x03\x1b\x1c\n\
    \xbe\x03\n\x04\x04\x0c\x02\x02\x12\x04\xb9\x03\x02,\x1a\xaf\x03\x20Requi\
    red.\x20A\x20nonempty\x20list\x20of\x20fields\x20to\x20change\x20in\x20t\
    he\x20existing\x20exclusion.\n\x20New\x20values\x20for\x20the\x20fields\
    \x20are\x20taken\x20from\x20the\x20corresponding\x20fields\x20in\x20the\
    \n\x20[LogExclusion][google.logging.v2.LogExclusion]\x20included\x20in\
    \x20this\x20request.\x20Fields\x20not\x20mentioned\x20in\n\x20`update_ma\
    sk`\x20are\x20not\x20changed\x20and\x20are\x20ignored\x20in\x20the\x20re\
    quest.\n\n\x20For\x20example,\x20to\x20change\x20the\x20filter\x20and\
    \x20description\x20of\x20an\x20exclusion,\n\x20specify\x20an\x20`update_\
    mask`\x20of\x20`\"filter,description\"`.\n\n\x0f\n\x05\x04\x0c\x02\x02\
    \x04\x12\x06\xb9\x03\x02\xb0\x03\x1d\n\r\n\x05\x04\x0c\x02\x02\x06\x12\
    \x04\xb9\x03\x02\x1b\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\xb9\x03\x1c'\
    \n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xb9\x03*+\n4\n\x02\x04\r\x12\x06\
    \xbd\x03\0\xc7\x03\x01\x1a&\x20The\x20parameters\x20to\x20`DeleteExclusi\
    on`.\n\n\x0b\n\x03\x04\r\x01\x12\x04\xbd\x03\x08\x1e\n\x86\x03\n\x04\x04\
    \r\x02\0\x12\x04\xc6\x03\x02\x12\x1a\xf7\x02\x20Required.\x20The\x20reso\
    urce\x20name\x20of\x20an\x20existing\x20exclusion\x20to\x20delete:\n\n\
    \x20\x20\x20\x20\x20\"projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]\"\
    \n\x20\x20\x20\x20\x20\"organizations/[ORGANIZATION_ID]/exclusions/[EXCL\
    USION_ID]\"\n\x20\x20\x20\x20\x20\"billingAccounts/[BILLING_ACCOUNT_ID]/\
    exclusions/[EXCLUSION_ID]\"\n\x20\x20\x20\x20\x20\"folders/[FOLDER_ID]/e\
    xclusions/[EXCLUSION_ID]\"\n\n\x20Example:\x20`\"projects/my-project-id/\
    exclusions/my-exclusion-id\"`.\n\n\x0f\n\x05\x04\r\x02\0\x04\x12\x06\xc6\
    \x03\x02\xbd\x03\x20\n\r\n\x05\x04\r\x02\0\x05\x12\x04\xc6\x03\x02\x08\n\
    \r\n\x05\x04\r\x02\0\x01\x12\x04\xc6\x03\t\r\n\r\n\x05\x04\r\x02\0\x03\
    \x12\x04\xc6\x03\x10\x11b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
