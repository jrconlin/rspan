// This file is generated by rust-protobuf 2.0.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct DeleteLogRequest {
    // message fields
    pub log_name: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DeleteLogRequest {
    pub fn new() -> DeleteLogRequest {
        ::std::default::Default::default()
    }

    // string log_name = 1;

    pub fn clear_log_name(&mut self) {
        self.log_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_log_name(&mut self, v: ::std::string::String) {
        self.log_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_log_name(&mut self) -> &mut ::std::string::String {
        &mut self.log_name
    }

    // Take field
    pub fn take_log_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.log_name, ::std::string::String::new())
    }

    pub fn get_log_name(&self) -> &str {
        &self.log_name
    }
}

impl ::protobuf::Message for DeleteLogRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.log_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.log_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.log_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.log_name.is_empty() {
            os.write_string(1, &self.log_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteLogRequest {
        DeleteLogRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "log_name",
                    |m: &DeleteLogRequest| { &m.log_name },
                    |m: &mut DeleteLogRequest| { &mut m.log_name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteLogRequest>(
                    "DeleteLogRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteLogRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteLogRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteLogRequest,
        };
        unsafe {
            instance.get(DeleteLogRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteLogRequest {
    fn clear(&mut self) {
        self.clear_log_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteLogRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteLogRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteLogEntriesRequest {
    // message fields
    pub log_name: ::std::string::String,
    pub resource: ::protobuf::SingularPtrField<super::super::super::api::monitored_resource::MonitoredResource>,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub entries: ::protobuf::RepeatedField<super::log_entry::LogEntry>,
    pub partial_success: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WriteLogEntriesRequest {
    pub fn new() -> WriteLogEntriesRequest {
        ::std::default::Default::default()
    }

    // string log_name = 1;

    pub fn clear_log_name(&mut self) {
        self.log_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_log_name(&mut self, v: ::std::string::String) {
        self.log_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_log_name(&mut self) -> &mut ::std::string::String {
        &mut self.log_name
    }

    // Take field
    pub fn take_log_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.log_name, ::std::string::String::new())
    }

    pub fn get_log_name(&self) -> &str {
        &self.log_name
    }

    // .google.api.MonitoredResource resource = 2;

    pub fn clear_resource(&mut self) {
        self.resource.clear();
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: super::super::super::api::monitored_resource::MonitoredResource) {
        self.resource = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut super::super::super::api::monitored_resource::MonitoredResource {
        if self.resource.is_none() {
            self.resource.set_default();
        }
        self.resource.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource(&mut self) -> super::super::super::api::monitored_resource::MonitoredResource {
        self.resource.take().unwrap_or_else(|| super::super::super::api::monitored_resource::MonitoredResource::new())
    }

    pub fn get_resource(&self) -> &super::super::super::api::monitored_resource::MonitoredResource {
        self.resource.as_ref().unwrap_or_else(|| super::super::super::api::monitored_resource::MonitoredResource::default_instance())
    }

    // repeated .google.logging.v2.WriteLogEntriesRequest.LabelsEntry labels = 3;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }

    // repeated .google.logging.v2.LogEntry entries = 4;

    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<super::log_entry::LogEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<super::log_entry::LogEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<super::log_entry::LogEntry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }

    pub fn get_entries(&self) -> &[super::log_entry::LogEntry] {
        &self.entries
    }

    // bool partial_success = 5;

    pub fn clear_partial_success(&mut self) {
        self.partial_success = false;
    }

    // Param is passed by value, moved
    pub fn set_partial_success(&mut self, v: bool) {
        self.partial_success = v;
    }

    pub fn get_partial_success(&self) -> bool {
        self.partial_success
    }
}

impl ::protobuf::Message for WriteLogEntriesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.resource {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.log_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resource)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.partial_success = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.log_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.log_name);
        }
        if let Some(ref v) = self.resource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.labels);
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.partial_success != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.log_name.is_empty() {
            os.write_string(1, &self.log_name)?;
        }
        if let Some(ref v) = self.resource.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.labels, os)?;
        for v in &self.entries {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.partial_success != false {
            os.write_bool(5, self.partial_success)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteLogEntriesRequest {
        WriteLogEntriesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "log_name",
                    |m: &WriteLogEntriesRequest| { &m.log_name },
                    |m: &mut WriteLogEntriesRequest| { &mut m.log_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::super::super::api::monitored_resource::MonitoredResource>>(
                    "resource",
                    |m: &WriteLogEntriesRequest| { &m.resource },
                    |m: &mut WriteLogEntriesRequest| { &mut m.resource },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "labels",
                    |m: &WriteLogEntriesRequest| { &m.labels },
                    |m: &mut WriteLogEntriesRequest| { &mut m.labels },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::log_entry::LogEntry>>(
                    "entries",
                    |m: &WriteLogEntriesRequest| { &m.entries },
                    |m: &mut WriteLogEntriesRequest| { &mut m.entries },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "partial_success",
                    |m: &WriteLogEntriesRequest| { &m.partial_success },
                    |m: &mut WriteLogEntriesRequest| { &mut m.partial_success },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WriteLogEntriesRequest>(
                    "WriteLogEntriesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WriteLogEntriesRequest {
        static mut instance: ::protobuf::lazy::Lazy<WriteLogEntriesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WriteLogEntriesRequest,
        };
        unsafe {
            instance.get(WriteLogEntriesRequest::new)
        }
    }
}

impl ::protobuf::Clear for WriteLogEntriesRequest {
    fn clear(&mut self) {
        self.clear_log_name();
        self.clear_resource();
        self.clear_labels();
        self.clear_entries();
        self.clear_partial_success();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteLogEntriesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteLogEntriesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteLogEntriesResponse {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WriteLogEntriesResponse {
    pub fn new() -> WriteLogEntriesResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for WriteLogEntriesResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteLogEntriesResponse {
        WriteLogEntriesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<WriteLogEntriesResponse>(
                    "WriteLogEntriesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WriteLogEntriesResponse {
        static mut instance: ::protobuf::lazy::Lazy<WriteLogEntriesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WriteLogEntriesResponse,
        };
        unsafe {
            instance.get(WriteLogEntriesResponse::new)
        }
    }
}

impl ::protobuf::Clear for WriteLogEntriesResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteLogEntriesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteLogEntriesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteLogEntriesPartialErrors {
    // message fields
    pub log_entry_errors: ::std::collections::HashMap<i32, super::super::super::rpc::status::Status>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WriteLogEntriesPartialErrors {
    pub fn new() -> WriteLogEntriesPartialErrors {
        ::std::default::Default::default()
    }

    // repeated .google.logging.v2.WriteLogEntriesPartialErrors.LogEntryErrorsEntry log_entry_errors = 1;

    pub fn clear_log_entry_errors(&mut self) {
        self.log_entry_errors.clear();
    }

    // Param is passed by value, moved
    pub fn set_log_entry_errors(&mut self, v: ::std::collections::HashMap<i32, super::super::super::rpc::status::Status>) {
        self.log_entry_errors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_log_entry_errors(&mut self) -> &mut ::std::collections::HashMap<i32, super::super::super::rpc::status::Status> {
        &mut self.log_entry_errors
    }

    // Take field
    pub fn take_log_entry_errors(&mut self) -> ::std::collections::HashMap<i32, super::super::super::rpc::status::Status> {
        ::std::mem::replace(&mut self.log_entry_errors, ::std::collections::HashMap::new())
    }

    pub fn get_log_entry_errors(&self) -> &::std::collections::HashMap<i32, super::super::super::rpc::status::Status> {
        &self.log_entry_errors
    }
}

impl ::protobuf::Message for WriteLogEntriesPartialErrors {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<super::super::super::rpc::status::Status>>(wire_type, is, &mut self.log_entry_errors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<super::super::super::rpc::status::Status>>(1, &self.log_entry_errors);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<super::super::super::rpc::status::Status>>(1, &self.log_entry_errors, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteLogEntriesPartialErrors {
        WriteLogEntriesPartialErrors::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<super::super::super::rpc::status::Status>>(
                    "log_entry_errors",
                    |m: &WriteLogEntriesPartialErrors| { &m.log_entry_errors },
                    |m: &mut WriteLogEntriesPartialErrors| { &mut m.log_entry_errors },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WriteLogEntriesPartialErrors>(
                    "WriteLogEntriesPartialErrors",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WriteLogEntriesPartialErrors {
        static mut instance: ::protobuf::lazy::Lazy<WriteLogEntriesPartialErrors> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WriteLogEntriesPartialErrors,
        };
        unsafe {
            instance.get(WriteLogEntriesPartialErrors::new)
        }
    }
}

impl ::protobuf::Clear for WriteLogEntriesPartialErrors {
    fn clear(&mut self) {
        self.clear_log_entry_errors();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteLogEntriesPartialErrors {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteLogEntriesPartialErrors {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListLogEntriesRequest {
    // message fields
    pub project_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub resource_names: ::protobuf::RepeatedField<::std::string::String>,
    pub filter: ::std::string::String,
    pub order_by: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListLogEntriesRequest {
    pub fn new() -> ListLogEntriesRequest {
        ::std::default::Default::default()
    }

    // repeated string project_ids = 1;

    pub fn clear_project_ids(&mut self) {
        self.project_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.project_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_project_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.project_ids
    }

    // Take field
    pub fn take_project_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.project_ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_project_ids(&self) -> &[::std::string::String] {
        &self.project_ids
    }

    // repeated string resource_names = 8;

    pub fn clear_resource_names(&mut self) {
        self.resource_names.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.resource_names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resource_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.resource_names
    }

    // Take field
    pub fn take_resource_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.resource_names, ::protobuf::RepeatedField::new())
    }

    pub fn get_resource_names(&self) -> &[::std::string::String] {
        &self.resource_names
    }

    // string filter = 2;

    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }

    pub fn get_filter(&self) -> &str {
        &self.filter
    }

    // string order_by = 3;

    pub fn clear_order_by(&mut self) {
        self.order_by.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_by(&mut self, v: ::std::string::String) {
        self.order_by = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_by(&mut self) -> &mut ::std::string::String {
        &mut self.order_by
    }

    // Take field
    pub fn take_order_by(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_by, ::std::string::String::new())
    }

    pub fn get_order_by(&self) -> &str {
        &self.order_by
    }

    // int32 page_size = 4;

    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }

    // string page_token = 5;

    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
}

impl ::protobuf::Message for ListLogEntriesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.project_ids)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.resource_names)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_by)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.project_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.resource_names {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.filter);
        }
        if !self.order_by.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.order_by);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(4, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.project_ids {
            os.write_string(1, &v)?;
        };
        for v in &self.resource_names {
            os.write_string(8, &v)?;
        };
        if !self.filter.is_empty() {
            os.write_string(2, &self.filter)?;
        }
        if !self.order_by.is_empty() {
            os.write_string(3, &self.order_by)?;
        }
        if self.page_size != 0 {
            os.write_int32(4, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(5, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListLogEntriesRequest {
        ListLogEntriesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "project_ids",
                    |m: &ListLogEntriesRequest| { &m.project_ids },
                    |m: &mut ListLogEntriesRequest| { &mut m.project_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "resource_names",
                    |m: &ListLogEntriesRequest| { &m.resource_names },
                    |m: &mut ListLogEntriesRequest| { &mut m.resource_names },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "filter",
                    |m: &ListLogEntriesRequest| { &m.filter },
                    |m: &mut ListLogEntriesRequest| { &mut m.filter },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "order_by",
                    |m: &ListLogEntriesRequest| { &m.order_by },
                    |m: &mut ListLogEntriesRequest| { &mut m.order_by },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "page_size",
                    |m: &ListLogEntriesRequest| { &m.page_size },
                    |m: &mut ListLogEntriesRequest| { &mut m.page_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "page_token",
                    |m: &ListLogEntriesRequest| { &m.page_token },
                    |m: &mut ListLogEntriesRequest| { &mut m.page_token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListLogEntriesRequest>(
                    "ListLogEntriesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListLogEntriesRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListLogEntriesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListLogEntriesRequest,
        };
        unsafe {
            instance.get(ListLogEntriesRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListLogEntriesRequest {
    fn clear(&mut self) {
        self.clear_project_ids();
        self.clear_resource_names();
        self.clear_filter();
        self.clear_order_by();
        self.clear_page_size();
        self.clear_page_token();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListLogEntriesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListLogEntriesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListLogEntriesResponse {
    // message fields
    pub entries: ::protobuf::RepeatedField<super::log_entry::LogEntry>,
    pub next_page_token: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListLogEntriesResponse {
    pub fn new() -> ListLogEntriesResponse {
        ::std::default::Default::default()
    }

    // repeated .google.logging.v2.LogEntry entries = 1;

    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<super::log_entry::LogEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<super::log_entry::LogEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<super::log_entry::LogEntry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }

    pub fn get_entries(&self) -> &[super::log_entry::LogEntry] {
        &self.entries
    }

    // string next_page_token = 2;

    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }

    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
}

impl ::protobuf::Message for ListLogEntriesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListLogEntriesResponse {
        ListLogEntriesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::log_entry::LogEntry>>(
                    "entries",
                    |m: &ListLogEntriesResponse| { &m.entries },
                    |m: &mut ListLogEntriesResponse| { &mut m.entries },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "next_page_token",
                    |m: &ListLogEntriesResponse| { &m.next_page_token },
                    |m: &mut ListLogEntriesResponse| { &mut m.next_page_token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListLogEntriesResponse>(
                    "ListLogEntriesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListLogEntriesResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListLogEntriesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListLogEntriesResponse,
        };
        unsafe {
            instance.get(ListLogEntriesResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListLogEntriesResponse {
    fn clear(&mut self) {
        self.clear_entries();
        self.clear_next_page_token();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListLogEntriesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListLogEntriesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListMonitoredResourceDescriptorsRequest {
    // message fields
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListMonitoredResourceDescriptorsRequest {
    pub fn new() -> ListMonitoredResourceDescriptorsRequest {
        ::std::default::Default::default()
    }

    // int32 page_size = 1;

    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }

    // string page_token = 2;

    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
}

impl ::protobuf::Message for ListMonitoredResourceDescriptorsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(1, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.page_size != 0 {
            os.write_int32(1, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(2, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListMonitoredResourceDescriptorsRequest {
        ListMonitoredResourceDescriptorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "page_size",
                    |m: &ListMonitoredResourceDescriptorsRequest| { &m.page_size },
                    |m: &mut ListMonitoredResourceDescriptorsRequest| { &mut m.page_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "page_token",
                    |m: &ListMonitoredResourceDescriptorsRequest| { &m.page_token },
                    |m: &mut ListMonitoredResourceDescriptorsRequest| { &mut m.page_token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListMonitoredResourceDescriptorsRequest>(
                    "ListMonitoredResourceDescriptorsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListMonitoredResourceDescriptorsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListMonitoredResourceDescriptorsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListMonitoredResourceDescriptorsRequest,
        };
        unsafe {
            instance.get(ListMonitoredResourceDescriptorsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListMonitoredResourceDescriptorsRequest {
    fn clear(&mut self) {
        self.clear_page_size();
        self.clear_page_token();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListMonitoredResourceDescriptorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListMonitoredResourceDescriptorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListMonitoredResourceDescriptorsResponse {
    // message fields
    pub resource_descriptors: ::protobuf::RepeatedField<super::super::super::api::monitored_resource::MonitoredResourceDescriptor>,
    pub next_page_token: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListMonitoredResourceDescriptorsResponse {
    pub fn new() -> ListMonitoredResourceDescriptorsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.api.MonitoredResourceDescriptor resource_descriptors = 1;

    pub fn clear_resource_descriptors(&mut self) {
        self.resource_descriptors.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource_descriptors(&mut self, v: ::protobuf::RepeatedField<super::super::super::api::monitored_resource::MonitoredResourceDescriptor>) {
        self.resource_descriptors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resource_descriptors(&mut self) -> &mut ::protobuf::RepeatedField<super::super::super::api::monitored_resource::MonitoredResourceDescriptor> {
        &mut self.resource_descriptors
    }

    // Take field
    pub fn take_resource_descriptors(&mut self) -> ::protobuf::RepeatedField<super::super::super::api::monitored_resource::MonitoredResourceDescriptor> {
        ::std::mem::replace(&mut self.resource_descriptors, ::protobuf::RepeatedField::new())
    }

    pub fn get_resource_descriptors(&self) -> &[super::super::super::api::monitored_resource::MonitoredResourceDescriptor] {
        &self.resource_descriptors
    }

    // string next_page_token = 2;

    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }

    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
}

impl ::protobuf::Message for ListMonitoredResourceDescriptorsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.resource_descriptors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resource_descriptors)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.resource_descriptors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.resource_descriptors {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListMonitoredResourceDescriptorsResponse {
        ListMonitoredResourceDescriptorsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::super::super::api::monitored_resource::MonitoredResourceDescriptor>>(
                    "resource_descriptors",
                    |m: &ListMonitoredResourceDescriptorsResponse| { &m.resource_descriptors },
                    |m: &mut ListMonitoredResourceDescriptorsResponse| { &mut m.resource_descriptors },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "next_page_token",
                    |m: &ListMonitoredResourceDescriptorsResponse| { &m.next_page_token },
                    |m: &mut ListMonitoredResourceDescriptorsResponse| { &mut m.next_page_token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListMonitoredResourceDescriptorsResponse>(
                    "ListMonitoredResourceDescriptorsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListMonitoredResourceDescriptorsResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListMonitoredResourceDescriptorsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListMonitoredResourceDescriptorsResponse,
        };
        unsafe {
            instance.get(ListMonitoredResourceDescriptorsResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListMonitoredResourceDescriptorsResponse {
    fn clear(&mut self) {
        self.clear_resource_descriptors();
        self.clear_next_page_token();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListMonitoredResourceDescriptorsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListMonitoredResourceDescriptorsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListLogsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListLogsRequest {
    pub fn new() -> ListLogsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;

    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    pub fn get_parent(&self) -> &str {
        &self.parent
    }

    // int32 page_size = 2;

    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }

    // string page_token = 3;

    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
}

impl ::protobuf::Message for ListLogsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListLogsRequest {
        ListLogsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "parent",
                    |m: &ListLogsRequest| { &m.parent },
                    |m: &mut ListLogsRequest| { &mut m.parent },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "page_size",
                    |m: &ListLogsRequest| { &m.page_size },
                    |m: &mut ListLogsRequest| { &mut m.page_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "page_token",
                    |m: &ListLogsRequest| { &m.page_token },
                    |m: &mut ListLogsRequest| { &mut m.page_token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListLogsRequest>(
                    "ListLogsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListLogsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListLogsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListLogsRequest,
        };
        unsafe {
            instance.get(ListLogsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListLogsRequest {
    fn clear(&mut self) {
        self.clear_parent();
        self.clear_page_size();
        self.clear_page_token();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListLogsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListLogsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListLogsResponse {
    // message fields
    pub log_names: ::protobuf::RepeatedField<::std::string::String>,
    pub next_page_token: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListLogsResponse {
    pub fn new() -> ListLogsResponse {
        ::std::default::Default::default()
    }

    // repeated string log_names = 3;

    pub fn clear_log_names(&mut self) {
        self.log_names.clear();
    }

    // Param is passed by value, moved
    pub fn set_log_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.log_names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_log_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.log_names
    }

    // Take field
    pub fn take_log_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.log_names, ::protobuf::RepeatedField::new())
    }

    pub fn get_log_names(&self) -> &[::std::string::String] {
        &self.log_names
    }

    // string next_page_token = 2;

    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }

    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
}

impl ::protobuf::Message for ListLogsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.log_names)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.log_names {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.log_names {
            os.write_string(3, &v)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListLogsResponse {
        ListLogsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "log_names",
                    |m: &ListLogsResponse| { &m.log_names },
                    |m: &mut ListLogsResponse| { &mut m.log_names },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "next_page_token",
                    |m: &ListLogsResponse| { &m.next_page_token },
                    |m: &mut ListLogsResponse| { &mut m.next_page_token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListLogsResponse>(
                    "ListLogsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListLogsResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListLogsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListLogsResponse,
        };
        unsafe {
            instance.get(ListLogsResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListLogsResponse {
    fn clear(&mut self) {
        self.clear_log_names();
        self.clear_next_page_token();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListLogsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListLogsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1fgoogle/logging/v2/logging.proto\x12\x11google.logging.v2\x1a\x1cgo\
    ogle/api/annotations.proto\x1a#google/api/monitored_resource.proto\x1a!g\
    oogle/logging/v2/log_entry.proto\x1a\x1egoogle/protobuf/duration.proto\
    \x1a\x1bgoogle/protobuf/empty.proto\x1a\x1fgoogle/protobuf/timestamp.pro\
    to\x1a\x17google/rpc/status.proto\"-\n\x10DeleteLogRequest\x12\x19\n\x08\
    log_name\x18\x01\x20\x01(\tR\x07logName\"\xd8\x02\n\x16WriteLogEntriesRe\
    quest\x12\x19\n\x08log_name\x18\x01\x20\x01(\tR\x07logName\x129\n\x08res\
    ource\x18\x02\x20\x01(\x0b2\x1d.google.api.MonitoredResourceR\x08resourc\
    e\x12M\n\x06labels\x18\x03\x20\x03(\x0b25.google.logging.v2.WriteLogEntr\
    iesRequest.LabelsEntryR\x06labels\x125\n\x07entries\x18\x04\x20\x03(\x0b\
    2\x1b.google.logging.v2.LogEntryR\x07entries\x12'\n\x0fpartial_success\
    \x18\x05\x20\x01(\x08R\x0epartialSuccess\x1a9\n\x0bLabelsEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01\"\x19\n\x17WriteLogEntriesResponse\"\xe4\x01\n\x1cW\
    riteLogEntriesPartialErrors\x12m\n\x10log_entry_errors\x18\x01\x20\x03(\
    \x0b2C.google.logging.v2.WriteLogEntriesPartialErrors.LogEntryErrorsEntr\
    yR\x0elogEntryErrors\x1aU\n\x13LogEntryErrorsEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\x05R\x03key\x12(\n\x05value\x18\x02\x20\x01(\x0b2\x12.goog\
    le.rpc.StatusR\x05value:\x028\x01\"\xce\x01\n\x15ListLogEntriesRequest\
    \x12\x1f\n\x0bproject_ids\x18\x01\x20\x03(\tR\nprojectIds\x12%\n\x0ereso\
    urce_names\x18\x08\x20\x03(\tR\rresourceNames\x12\x16\n\x06filter\x18\
    \x02\x20\x01(\tR\x06filter\x12\x19\n\x08order_by\x18\x03\x20\x01(\tR\x07\
    orderBy\x12\x1b\n\tpage_size\x18\x04\x20\x01(\x05R\x08pageSize\x12\x1d\n\
    \npage_token\x18\x05\x20\x01(\tR\tpageToken\"w\n\x16ListLogEntriesRespon\
    se\x125\n\x07entries\x18\x01\x20\x03(\x0b2\x1b.google.logging.v2.LogEntr\
    yR\x07entries\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageTok\
    en\"e\n'ListMonitoredResourceDescriptorsRequest\x12\x1b\n\tpage_size\x18\
    \x01\x20\x01(\x05R\x08pageSize\x12\x1d\n\npage_token\x18\x02\x20\x01(\tR\
    \tpageToken\"\xae\x01\n(ListMonitoredResourceDescriptorsResponse\x12Z\n\
    \x14resource_descriptors\x18\x01\x20\x03(\x0b2'.google.api.MonitoredReso\
    urceDescriptorR\x13resourceDescriptors\x12&\n\x0fnext_page_token\x18\x02\
    \x20\x01(\tR\rnextPageToken\"e\n\x0fListLogsRequest\x12\x16\n\x06parent\
    \x18\x01\x20\x01(\tR\x06parent\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05\
    R\x08pageSize\x12\x1d\n\npage_token\x18\x03\x20\x01(\tR\tpageToken\"W\n\
    \x10ListLogsResponse\x12\x1b\n\tlog_names\x18\x03\x20\x03(\tR\x08logName\
    s\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToken2\xd5\x05\
    \n\x10LoggingServiceV2\x12w\n\tDeleteLog\x12#.google.logging.v2.DeleteLo\
    gRequest\x1a\x16.google.protobuf.Empty\"-\x82\xd3\xe4\x93\x02'*%/v2beta1\
    /{log_name=projects/*/logs/*}\x12\x86\x01\n\x0fWriteLogEntries\x12).goog\
    le.logging.v2.WriteLogEntriesRequest\x1a*.google.logging.v2.WriteLogEntr\
    iesResponse\"\x1c\x82\xd3\xe4\x93\x02\x16\"\x11/v2/entries:write:\x01*\
    \x12\x82\x01\n\x0eListLogEntries\x12(.google.logging.v2.ListLogEntriesRe\
    quest\x1a).google.logging.v2.ListLogEntriesResponse\"\x1b\x82\xd3\xe4\
    \x93\x02\x15\"\x10/v2/entries:list:\x01*\x12\xc5\x01\n\x20ListMonitoredR\
    esourceDescriptors\x12:.google.logging.v2.ListMonitoredResourceDescripto\
    rsRequest\x1a;.google.logging.v2.ListMonitoredResourceDescriptorsRespons\
    e\"(\x82\xd3\xe4\x93\x02\"\x12\x20/v2/monitoredResourceDescriptors\x12r\
    \n\x08ListLogs\x12\".google.logging.v2.ListLogsRequest\x1a#.google.loggi\
    ng.v2.ListLogsResponse\"\x1d\x82\xd3\xe4\x93\x02\x17\x12\x15/v2/{parent=\
    */*}/logsB\x98\x01\n\x15com.google.logging.v2B\x0cLoggingProtoP\x01Z8goo\
    gle.golang.org/genproto/googleapis/logging/v2;logging\xf8\x01\x01\xaa\
    \x02\x17Google.Cloud.Logging.V2\xca\x02\x17Google\\Cloud\\Logging\\V2J\
    \x96j\n\x07\x12\x05\x0e\0\xad\x02\x01\n\xbd\x04\n\x01\x0c\x12\x03\x0e\0\
    \x122\xb2\x04\x20Copyright\x202017\x20Google\x20Inc.\n\n\x20Licensed\x20\
    under\x20the\x20Apache\x20License,\x20Version\x202.0\x20(the\x20\"Licens\
    e\");\n\x20you\x20may\x20not\x20use\x20this\x20file\x20except\x20in\x20c\
    ompliance\x20with\x20the\x20License.\n\x20You\x20may\x20obtain\x20a\x20c\
    opy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20\x20http://www.apac\
    he.org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\x20by\x20applicabl\
    e\x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20software\n\x20distri\
    buted\x20under\x20the\x20License\x20is\x20distributed\x20on\x20an\x20\"A\
    S\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\
    \x20ANY\x20KIND,\x20either\x20express\x20or\x20implied.\n\x20See\x20the\
    \x20License\x20for\x20the\x20specific\x20language\x20governing\x20permis\
    sions\x20and\n\x20limitations\x20under\x20the\x20License.\n\n\x08\n\x01\
    \x02\x12\x03\x10\x08\x19\n\t\n\x02\x03\0\x12\x03\x12\x07%\n\t\n\x02\x03\
    \x01\x12\x03\x13\x07,\n\t\n\x02\x03\x02\x12\x03\x14\x07*\n\t\n\x02\x03\
    \x03\x12\x03\x15\x07'\n\t\n\x02\x03\x04\x12\x03\x16\x07$\n\t\n\x02\x03\
    \x05\x12\x03\x17\x07(\n\t\n\x02\x03\x06\x12\x03\x18\x07\x20\n\x08\n\x01\
    \x08\x12\x03\x1a\0\x1f\n\x0b\n\x04\x08\xe7\x07\0\x12\x03\x1a\0\x1f\n\x0c\
    \n\x05\x08\xe7\x07\0\x02\x12\x03\x1a\x07\x17\n\r\n\x06\x08\xe7\x07\0\x02\
    \0\x12\x03\x1a\x07\x17\n\x0e\n\x07\x08\xe7\x07\0\x02\0\x01\x12\x03\x1a\
    \x07\x17\n\x0c\n\x05\x08\xe7\x07\0\x03\x12\x03\x1a\x1a\x1e\n\x08\n\x01\
    \x08\x12\x03\x1b\04\n\x0b\n\x04\x08\xe7\x07\x01\x12\x03\x1b\04\n\x0c\n\
    \x05\x08\xe7\x07\x01\x02\x12\x03\x1b\x07\x17\n\r\n\x06\x08\xe7\x07\x01\
    \x02\0\x12\x03\x1b\x07\x17\n\x0e\n\x07\x08\xe7\x07\x01\x02\0\x01\x12\x03\
    \x1b\x07\x17\n\x0c\n\x05\x08\xe7\x07\x01\x07\x12\x03\x1b\x1a3\n\x08\n\
    \x01\x08\x12\x03\x1c\0O\n\x0b\n\x04\x08\xe7\x07\x02\x12\x03\x1c\0O\n\x0c\
    \n\x05\x08\xe7\x07\x02\x02\x12\x03\x1c\x07\x11\n\r\n\x06\x08\xe7\x07\x02\
    \x02\0\x12\x03\x1c\x07\x11\n\x0e\n\x07\x08\xe7\x07\x02\x02\0\x01\x12\x03\
    \x1c\x07\x11\n\x0c\n\x05\x08\xe7\x07\x02\x07\x12\x03\x1c\x14N\n\x08\n\
    \x01\x08\x12\x03\x1d\0\"\n\x0b\n\x04\x08\xe7\x07\x03\x12\x03\x1d\0\"\n\
    \x0c\n\x05\x08\xe7\x07\x03\x02\x12\x03\x1d\x07\x1a\n\r\n\x06\x08\xe7\x07\
    \x03\x02\0\x12\x03\x1d\x07\x1a\n\x0e\n\x07\x08\xe7\x07\x03\x02\0\x01\x12\
    \x03\x1d\x07\x1a\n\x0c\n\x05\x08\xe7\x07\x03\x03\x12\x03\x1d\x1d!\n\x08\
    \n\x01\x08\x12\x03\x1e\0-\n\x0b\n\x04\x08\xe7\x07\x04\x12\x03\x1e\0-\n\
    \x0c\n\x05\x08\xe7\x07\x04\x02\x12\x03\x1e\x07\x1b\n\r\n\x06\x08\xe7\x07\
    \x04\x02\0\x12\x03\x1e\x07\x1b\n\x0e\n\x07\x08\xe7\x07\x04\x02\0\x01\x12\
    \x03\x1e\x07\x1b\n\x0c\n\x05\x08\xe7\x07\x04\x07\x12\x03\x1e\x1e,\n\x08\
    \n\x01\x08\x12\x03\x1f\0.\n\x0b\n\x04\x08\xe7\x07\x05\x12\x03\x1f\0.\n\
    \x0c\n\x05\x08\xe7\x07\x05\x02\x12\x03\x1f\x07\x13\n\r\n\x06\x08\xe7\x07\
    \x05\x02\0\x12\x03\x1f\x07\x13\n\x0e\n\x07\x08\xe7\x07\x05\x02\0\x01\x12\
    \x03\x1f\x07\x13\n\x0c\n\x05\x08\xe7\x07\x05\x07\x12\x03\x1f\x16-\n\x08\
    \n\x01\x08\x12\x03\x20\04\n\x0b\n\x04\x08\xe7\x07\x06\x12\x03\x20\04\n\
    \x0c\n\x05\x08\xe7\x07\x06\x02\x12\x03\x20\x07\x14\n\r\n\x06\x08\xe7\x07\
    \x06\x02\0\x12\x03\x20\x07\x14\n\x0e\n\x07\x08\xe7\x07\x06\x02\0\x01\x12\
    \x03\x20\x07\x14\n\x0c\n\x05\x08\xe7\x07\x06\x07\x12\x03\x20\x173\n6\n\
    \x02\x06\0\x12\x04$\0J\x01\x1a*\x20Service\x20for\x20ingesting\x20and\
    \x20querying\x20logs.\n\n\n\n\x03\x06\0\x01\x12\x03$\x08\x18\n\xb5\x01\n\
    \x04\x06\0\x02\0\x12\x04)\x02+\x03\x1a\xa6\x01\x20Deletes\x20all\x20the\
    \x20log\x20entries\x20in\x20a\x20log.\n\x20The\x20log\x20reappears\x20if\
    \x20it\x20receives\x20new\x20entries.\n\x20Log\x20entries\x20written\x20\
    shortly\x20before\x20the\x20delete\x20operation\x20might\x20not\x20be\n\
    \x20deleted.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03)\x06\x0f\n\x0c\n\x05\
    \x06\0\x02\0\x02\x12\x03)\x10\x20\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03)+@\
    \n\x0c\n\x05\x06\0\x02\0\x04\x12\x03*\x04S\n\x0f\n\x08\x06\0\x02\0\x04\
    \xe7\x07\0\x12\x03*\x04S\n\x10\n\t\x06\0\x02\0\x04\xe7\x07\0\x02\x12\x03\
    *\x0b\x1c\n\x11\n\n\x06\0\x02\0\x04\xe7\x07\0\x02\0\x12\x03*\x0b\x1c\n\
    \x12\n\x0b\x06\0\x02\0\x04\xe7\x07\0\x02\0\x01\x12\x03*\x0c\x1b\n\x10\n\
    \t\x06\0\x02\0\x04\xe7\x07\0\x08\x12\x03*\x1fR\n\xbd\x02\n\x04\x06\0\x02\
    \x01\x12\x044\x026\x03\x1a\xae\x02\x20##\x20Log\x20entry\x20resources\n\
    \n\x20Writes\x20log\x20entries\x20to\x20Stackdriver\x20Logging.\x20This\
    \x20API\x20method\x20is\x20the\n\x20only\x20way\x20to\x20send\x20log\x20\
    entries\x20to\x20Stackdriver\x20Logging.\x20This\x20method\n\x20is\x20us\
    ed,\x20directly\x20or\x20indirectly,\x20by\x20the\x20Stackdriver\x20Logg\
    ing\x20agent\n\x20(fluentd)\x20and\x20all\x20logging\x20libraries\x20con\
    figured\x20to\x20use\x20Stackdriver\n\x20Logging.\n\n\x0c\n\x05\x06\0\
    \x02\x01\x01\x12\x034\x06\x15\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x034\x16\
    ,\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x0347N\n\x0c\n\x05\x06\0\x02\x01\x04\
    \x12\x035\x04G\n\x0f\n\x08\x06\0\x02\x01\x04\xe7\x07\0\x12\x035\x04G\n\
    \x10\n\t\x06\0\x02\x01\x04\xe7\x07\0\x02\x12\x035\x0b\x1c\n\x11\n\n\x06\
    \0\x02\x01\x04\xe7\x07\0\x02\0\x12\x035\x0b\x1c\n\x12\n\x0b\x06\0\x02\
    \x01\x04\xe7\x07\0\x02\0\x01\x12\x035\x0c\x1b\n\x10\n\t\x06\0\x02\x01\
    \x04\xe7\x07\0\x08\x12\x035\x1fF\n\xb5\x01\n\x04\x06\0\x02\x02\x12\x04;\
    \x02=\x03\x1a\xa6\x01\x20Lists\x20log\x20entries.\x20\x20Use\x20this\x20\
    method\x20to\x20retrieve\x20log\x20entries\x20from\n\x20Stackdriver\x20L\
    ogging.\x20\x20For\x20ways\x20to\x20export\x20log\x20entries,\x20see\n\
    \x20[Exporting\x20Logs](/logging/docs/export).\n\n\x0c\n\x05\x06\0\x02\
    \x02\x01\x12\x03;\x06\x14\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03;\x15*\n\
    \x0c\n\x05\x06\0\x02\x02\x03\x12\x03;5K\n\x0c\n\x05\x06\0\x02\x02\x04\
    \x12\x03<\x04F\n\x0f\n\x08\x06\0\x02\x02\x04\xe7\x07\0\x12\x03<\x04F\n\
    \x10\n\t\x06\0\x02\x02\x04\xe7\x07\0\x02\x12\x03<\x0b\x1c\n\x11\n\n\x06\
    \0\x02\x02\x04\xe7\x07\0\x02\0\x12\x03<\x0b\x1c\n\x12\n\x0b\x06\0\x02\
    \x02\x04\xe7\x07\0\x02\0\x01\x12\x03<\x0c\x1b\n\x10\n\t\x06\0\x02\x02\
    \x04\xe7\x07\0\x08\x12\x03<\x1fE\n`\n\x04\x06\0\x02\x03\x12\x04A\x02C\
    \x03\x1aR\x20Lists\x20the\x20descriptors\x20for\x20monitored\x20resource\
    \x20types\x20used\x20by\x20Stackdriver\n\x20Logging.\n\n\x0c\n\x05\x06\0\
    \x02\x03\x01\x12\x03A\x06&\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03A'N\n\r\
    \n\x05\x06\0\x02\x03\x03\x12\x04AY\x81\x01\n\x0c\n\x05\x06\0\x02\x03\x04\
    \x12\x03B\x04K\n\x0f\n\x08\x06\0\x02\x03\x04\xe7\x07\0\x12\x03B\x04K\n\
    \x10\n\t\x06\0\x02\x03\x04\xe7\x07\0\x02\x12\x03B\x0b\x1c\n\x11\n\n\x06\
    \0\x02\x03\x04\xe7\x07\0\x02\0\x12\x03B\x0b\x1c\n\x12\n\x0b\x06\0\x02\
    \x03\x04\xe7\x07\0\x02\0\x01\x12\x03B\x0c\x1b\n\x10\n\t\x06\0\x02\x03\
    \x04\xe7\x07\0\x08\x12\x03B\x1fJ\n\x81\x01\n\x04\x06\0\x02\x04\x12\x04G\
    \x02I\x03\x1as\x20Lists\x20the\x20logs\x20in\x20projects,\x20organizatio\
    ns,\x20folders,\x20or\x20billing\x20accounts.\n\x20Only\x20logs\x20that\
    \x20have\x20entries\x20are\x20listed.\n\n\x0c\n\x05\x06\0\x02\x04\x01\
    \x12\x03G\x06\x0e\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03G\x0f\x1e\n\x0c\n\
    \x05\x06\0\x02\x04\x03\x12\x03G)9\n\x0c\n\x05\x06\0\x02\x04\x04\x12\x03H\
    \x04@\n\x0f\n\x08\x06\0\x02\x04\x04\xe7\x07\0\x12\x03H\x04@\n\x10\n\t\
    \x06\0\x02\x04\x04\xe7\x07\0\x02\x12\x03H\x0b\x1c\n\x11\n\n\x06\0\x02\
    \x04\x04\xe7\x07\0\x02\0\x12\x03H\x0b\x1c\n\x12\n\x0b\x06\0\x02\x04\x04\
    \xe7\x07\0\x02\0\x01\x12\x03H\x0c\x1b\n\x10\n\t\x06\0\x02\x04\x04\xe7\
    \x07\0\x08\x12\x03H\x1f?\n*\n\x02\x04\0\x12\x04M\0[\x01\x1a\x1e\x20The\
    \x20parameters\x20to\x20DeleteLog.\n\n\n\n\x03\x04\0\x01\x12\x03M\x08\
    \x18\n\x84\x04\n\x04\x04\0\x02\0\x12\x03Z\x02\x16\x1a\xf6\x03\x20Require\
    d.\x20The\x20resource\x20name\x20of\x20the\x20log\x20to\x20delete:\n\n\
    \x20\x20\x20\x20\x20\"projects/[PROJECT_ID]/logs/[LOG_ID]\"\n\x20\x20\
    \x20\x20\x20\"organizations/[ORGANIZATION_ID]/logs/[LOG_ID]\"\n\x20\x20\
    \x20\x20\x20\"billingAccounts/[BILLING_ACCOUNT_ID]/logs/[LOG_ID]\"\n\x20\
    \x20\x20\x20\x20\"folders/[FOLDER_ID]/logs/[LOG_ID]\"\n\n\x20`[LOG_ID]`\
    \x20must\x20be\x20URL-encoded.\x20For\x20example,\n\x20`\"projects/my-pr\
    oject-id/logs/syslog\"`,\n\x20`\"organizations/1234567890/logs/cloudreso\
    urcemanager.googleapis.com%2Factivity\"`.\n\x20For\x20more\x20informatio\
    n\x20about\x20log\x20names,\x20see\n\x20[LogEntry][google.logging.v2.Log\
    Entry].\n\n\r\n\x05\x04\0\x02\0\x04\x12\x04Z\x02M\x1a\n\x0c\n\x05\x04\0\
    \x02\0\x05\x12\x03Z\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03Z\t\x11\n\
    \x0c\n\x05\x04\0\x02\0\x03\x12\x03Z\x14\x15\n1\n\x02\x04\x01\x12\x05^\0\
    \x9b\x01\x01\x1a$\x20The\x20parameters\x20to\x20WriteLogEntries.\n\n\n\n\
    \x03\x04\x01\x01\x12\x03^\x08\x1e\n\xd8\x04\n\x04\x04\x01\x02\0\x12\x03l\
    \x02\x16\x1a\xca\x04\x20Optional.\x20A\x20default\x20log\x20resource\x20\
    name\x20that\x20is\x20assigned\x20to\x20all\x20log\x20entries\n\x20in\
    \x20`entries`\x20that\x20do\x20not\x20specify\x20a\x20value\x20for\x20`l\
    og_name`:\n\n\x20\x20\x20\x20\x20\"projects/[PROJECT_ID]/logs/[LOG_ID]\"\
    \n\x20\x20\x20\x20\x20\"organizations/[ORGANIZATION_ID]/logs/[LOG_ID]\"\
    \n\x20\x20\x20\x20\x20\"billingAccounts/[BILLING_ACCOUNT_ID]/logs/[LOG_I\
    D]\"\n\x20\x20\x20\x20\x20\"folders/[FOLDER_ID]/logs/[LOG_ID]\"\n\n\x20`\
    [LOG_ID]`\x20must\x20be\x20URL-encoded.\x20For\x20example,\n\x20`\"proje\
    cts/my-project-id/logs/syslog\"`\x20or\n\x20`\"organizations/1234567890/\
    logs/cloudresourcemanager.googleapis.com%2Factivity\"`.\n\x20For\x20more\
    \x20information\x20about\x20log\x20names,\x20see\n\x20[LogEntry][google.\
    logging.v2.LogEntry].\n\n\r\n\x05\x04\x01\x02\0\x04\x12\x04l\x02^\x20\n\
    \x0c\n\x05\x04\x01\x02\0\x05\x12\x03l\x02\x08\n\x0c\n\x05\x04\x01\x02\0\
    \x01\x12\x03l\t\x11\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03l\x14\x15\n\xd0\
    \x02\n\x04\x04\x01\x02\x01\x12\x03v\x02,\x1a\xc2\x02\x20Optional.\x20A\
    \x20default\x20monitored\x20resource\x20object\x20that\x20is\x20assigned\
    \x20to\x20all\x20log\n\x20entries\x20in\x20`entries`\x20that\x20do\x20no\
    t\x20specify\x20a\x20value\x20for\x20`resource`.\x20Example:\n\n\x20\x20\
    \x20\x20\x20{\x20\"type\":\x20\"gce_instance\",\n\x20\x20\x20\x20\x20\
    \x20\x20\"labels\":\x20{\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\"zone\":\
    \x20\"us-central1-a\",\x20\"instance_id\":\x20\"00000000000000000000\"\
    \x20}}\n\n\x20See\x20[LogEntry][google.logging.v2.LogEntry].\n\n\r\n\x05\
    \x04\x01\x02\x01\x04\x12\x04v\x02l\x16\n\x0c\n\x05\x04\x01\x02\x01\x06\
    \x12\x03v\x02\x1e\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03v\x1f'\n\x0c\n\
    \x05\x04\x01\x02\x01\x03\x12\x03v*+\n\x9b\x02\n\x04\x04\x01\x02\x02\x12\
    \x03|\x02!\x1a\x8d\x02\x20Optional.\x20Default\x20labels\x20that\x20are\
    \x20added\x20to\x20the\x20`labels`\x20field\x20of\x20all\x20log\n\x20ent\
    ries\x20in\x20`entries`.\x20If\x20a\x20log\x20entry\x20already\x20has\
    \x20a\x20label\x20with\x20the\x20same\x20key\n\x20as\x20a\x20label\x20in\
    \x20this\x20parameter,\x20then\x20the\x20log\x20entry's\x20label\x20is\
    \x20not\x20changed.\n\x20See\x20[LogEntry][google.logging.v2.LogEntry].\
    \n\n\r\n\x05\x04\x01\x02\x02\x04\x12\x04|\x02v,\n\x0c\n\x05\x04\x01\x02\
    \x02\x06\x12\x03|\x02\x15\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03|\x16\
    \x1c\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03|\x1f\x20\n\xba\t\n\x04\x04\
    \x01\x02\x03\x12\x04\x93\x01\x02\x20\x1a\xab\t\x20Required.\x20The\x20lo\
    g\x20entries\x20to\x20send\x20to\x20Stackdriver\x20Logging.\x20The\x20or\
    der\x20of\x20log\n\x20entries\x20in\x20this\x20list\x20does\x20not\x20ma\
    tter.\x20Values\x20supplied\x20in\x20this\x20method's\n\x20`log_name`,\
    \x20`resource`,\x20and\x20`labels`\x20fields\x20are\x20copied\x20into\
    \x20those\x20log\n\x20entries\x20in\x20this\x20list\x20that\x20do\x20not\
    \x20include\x20values\x20for\x20their\x20corresponding\n\x20fields.\x20F\
    or\x20more\x20information,\x20see\x20the\x20[LogEntry][google.logging.v2\
    .LogEntry]\x20type.\n\n\x20If\x20the\x20`timestamp`\x20or\x20`insert_id`\
    \x20fields\x20are\x20missing\x20in\x20log\x20entries,\x20then\n\x20this\
    \x20method\x20supplies\x20the\x20current\x20time\x20or\x20a\x20unique\
    \x20identifier,\x20respectively.\n\x20The\x20supplied\x20values\x20are\
    \x20chosen\x20so\x20that,\x20among\x20the\x20log\x20entries\x20that\x20d\
    id\x20not\n\x20supply\x20their\x20own\x20values,\x20the\x20entries\x20ea\
    rlier\x20in\x20the\x20list\x20will\x20sort\x20before\n\x20the\x20entries\
    \x20later\x20in\x20the\x20list.\x20See\x20the\x20`entries.list`\x20metho\
    d.\n\n\x20Log\x20entries\x20with\x20timestamps\x20that\x20are\x20more\
    \x20than\x20the\n\x20[logs\x20retention\x20period](/logging/quota-policy\
    )\x20in\x20the\x20past\x20or\x20more\x20than\n\x2024\x20hours\x20in\x20t\
    he\x20future\x20might\x20be\x20discarded.\x20Discarding\x20does\x20not\
    \x20return\n\x20an\x20error.\n\n\x20To\x20improve\x20throughput\x20and\
    \x20to\x20avoid\x20exceeding\x20the\n\x20[quota\x20limit](/logging/quota\
    -policy)\x20for\x20calls\x20to\x20`entries.write`,\n\x20you\x20should\
    \x20try\x20to\x20include\x20several\x20log\x20entries\x20in\x20this\x20l\
    ist,\n\x20rather\x20than\x20calling\x20this\x20method\x20for\x20each\x20\
    individual\x20log\x20entry.\n\n\r\n\x05\x04\x01\x02\x03\x04\x12\x04\x93\
    \x01\x02\n\n\r\n\x05\x04\x01\x02\x03\x06\x12\x04\x93\x01\x0b\x13\n\r\n\
    \x05\x04\x01\x02\x03\x01\x12\x04\x93\x01\x14\x1b\n\r\n\x05\x04\x01\x02\
    \x03\x03\x12\x04\x93\x01\x1e\x1f\n\xf6\x02\n\x04\x04\x01\x02\x04\x12\x04\
    \x9a\x01\x02\x1b\x1a\xe7\x02\x20Optional.\x20Whether\x20valid\x20entries\
    \x20should\x20be\x20written\x20even\x20if\x20some\x20other\n\x20entries\
    \x20fail\x20due\x20to\x20INVALID_ARGUMENT\x20or\x20PERMISSION_DENIED\x20\
    errors.\x20If\x20any\n\x20entry\x20is\x20not\x20written,\x20then\x20the\
    \x20response\x20status\x20is\x20the\x20error\x20associated\n\x20with\x20\
    one\x20of\x20the\x20failed\x20entries\x20and\x20the\x20response\x20inclu\
    des\x20error\x20details\n\x20keyed\x20by\x20the\x20entries'\x20zero-base\
    d\x20index\x20in\x20the\x20`entries.write`\x20method.\n\n\x0f\n\x05\x04\
    \x01\x02\x04\x04\x12\x06\x9a\x01\x02\x93\x01\x20\n\r\n\x05\x04\x01\x02\
    \x04\x05\x12\x04\x9a\x01\x02\x06\n\r\n\x05\x04\x01\x02\x04\x01\x12\x04\
    \x9a\x01\x07\x16\n\r\n\x05\x04\x01\x02\x04\x03\x12\x04\x9a\x01\x19\x1a\n\
    <\n\x02\x04\x02\x12\x06\x9f\x01\0\xa1\x01\x01\x1a.\x20Result\x20returned\
    \x20from\x20WriteLogEntries.\n\x20empty\n\n\x0b\n\x03\x04\x02\x01\x12\
    \x04\x9f\x01\x08\x1f\nG\n\x02\x04\x03\x12\x06\xa4\x01\0\xac\x01\x01\x1a9\
    \x20Error\x20details\x20for\x20WriteLogEntries\x20with\x20partial\x20suc\
    cess.\n\n\x0b\n\x03\x04\x03\x01\x12\x04\xa4\x01\x08$\n\xc0\x02\n\x04\x04\
    \x03\x02\0\x12\x04\xab\x01\x025\x1a\xb1\x02\x20When\x20`WriteLogEntriesR\
    equest.partial_success`\x20is\x20true,\x20records\x20the\x20error\n\x20s\
    tatus\x20for\x20entries\x20that\x20were\x20not\x20written\x20due\x20to\
    \x20a\x20permanent\x20error,\x20keyed\n\x20by\x20the\x20entry's\x20zero-\
    based\x20index\x20in\x20`WriteLogEntriesRequest.entries`.\n\n\x20Failed\
    \x20requests\x20for\x20which\x20no\x20entries\x20are\x20written\x20will\
    \x20not\x20include\n\x20per-entry\x20errors.\n\n\x0f\n\x05\x04\x03\x02\0\
    \x04\x12\x06\xab\x01\x02\xa4\x01&\n\r\n\x05\x04\x03\x02\0\x06\x12\x04\
    \xab\x01\x02\x1f\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xab\x01\x200\n\r\n\
    \x05\x04\x03\x02\0\x03\x12\x04\xab\x0134\n3\n\x02\x04\x04\x12\x06\xaf\
    \x01\0\xdd\x01\x01\x1a%\x20The\x20parameters\x20to\x20`ListLogEntries`.\
    \n\n\x0b\n\x03\x04\x04\x01\x12\x04\xaf\x01\x08\x1d\n\xb7\x02\n\x04\x04\
    \x04\x02\0\x12\x04\xb5\x01\x02\"\x1a\xa8\x02\x20Deprecated.\x20Use\x20`r\
    esource_names`\x20instead.\x20\x20One\x20or\x20more\x20project\x20identi\
    fiers\n\x20or\x20project\x20numbers\x20from\x20which\x20to\x20retrieve\
    \x20log\x20entries.\x20\x20Example:\n\x20`\"my-project-1A\"`.\x20If\x20p\
    resent,\x20these\x20project\x20identifiers\x20are\x20converted\x20to\n\
    \x20resource\x20name\x20format\x20and\x20added\x20to\x20the\x20list\x20o\
    f\x20resources\x20in\n\x20`resource_names`.\n\n\r\n\x05\x04\x04\x02\0\
    \x04\x12\x04\xb5\x01\x02\n\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\xb5\x01\
    \x0b\x11\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xb5\x01\x12\x1d\n\r\n\x05\
    \x04\x04\x02\0\x03\x12\x04\xb5\x01\x20!\n\xb6\x02\n\x04\x04\x04\x02\x01\
    \x12\x04\xc0\x01\x02%\x1a\xa7\x02\x20Required.\x20Names\x20of\x20one\x20\
    or\x20more\x20parent\x20resources\x20from\x20which\x20to\n\x20retrieve\
    \x20log\x20entries:\n\n\x20\x20\x20\x20\x20\"projects/[PROJECT_ID]\"\n\
    \x20\x20\x20\x20\x20\"organizations/[ORGANIZATION_ID]\"\n\x20\x20\x20\
    \x20\x20\"billingAccounts/[BILLING_ACCOUNT_ID]\"\n\x20\x20\x20\x20\x20\"\
    folders/[FOLDER_ID]\"\n\n\x20Projects\x20listed\x20in\x20the\x20`project\
    _ids`\x20field\x20are\x20added\x20to\x20this\x20list.\n\n\r\n\x05\x04\
    \x04\x02\x01\x04\x12\x04\xc0\x01\x02\n\n\r\n\x05\x04\x04\x02\x01\x05\x12\
    \x04\xc0\x01\x0b\x11\n\r\n\x05\x04\x04\x02\x01\x01\x12\x04\xc0\x01\x12\
    \x20\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\xc0\x01#$\n\xc9\x03\n\x04\x04\
    \x04\x02\x02\x12\x04\xc9\x01\x02\x14\x1a\xba\x03\x20Optional.\x20A\x20fi\
    lter\x20that\x20chooses\x20which\x20log\x20entries\x20to\x20return.\x20\
    \x20See\x20[Advanced\n\x20Logs\x20Filters](/logging/docs/view/advanced_f\
    ilters).\x20\x20Only\x20log\x20entries\x20that\n\x20match\x20the\x20filt\
    er\x20are\x20returned.\x20\x20An\x20empty\x20filter\x20matches\x20all\
    \x20log\x20entries\x20in\n\x20the\x20resources\x20listed\x20in\x20`resou\
    rce_names`.\x20Referencing\x20a\x20parent\x20resource\n\x20that\x20is\
    \x20not\x20listed\x20in\x20`resource_names`\x20will\x20cause\x20the\x20f\
    ilter\x20to\x20return\x20no\n\x20results.\n\x20The\x20maximum\x20length\
    \x20of\x20the\x20filter\x20is\x2020000\x20characters.\n\n\x0f\n\x05\x04\
    \x04\x02\x02\x04\x12\x06\xc9\x01\x02\xc0\x01%\n\r\n\x05\x04\x04\x02\x02\
    \x05\x12\x04\xc9\x01\x02\x08\n\r\n\x05\x04\x04\x02\x02\x01\x12\x04\xc9\
    \x01\t\x0f\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\xc9\x01\x12\x13\n\xb0\
    \x03\n\x04\x04\x04\x02\x03\x12\x04\xd1\x01\x02\x16\x1a\xa1\x03\x20Option\
    al.\x20How\x20the\x20results\x20should\x20be\x20sorted.\x20\x20Presently\
    ,\x20the\x20only\x20permitted\n\x20values\x20are\x20`\"timestamp\x20asc\
    \"`\x20(default)\x20and\x20`\"timestamp\x20desc\"`.\x20The\x20first\n\
    \x20option\x20returns\x20entries\x20in\x20order\x20of\x20increasing\x20v\
    alues\x20of\n\x20`LogEntry.timestamp`\x20(oldest\x20first),\x20and\x20th\
    e\x20second\x20option\x20returns\x20entries\n\x20in\x20order\x20of\x20de\
    creasing\x20timestamps\x20(newest\x20first).\x20\x20Entries\x20with\x20e\
    qual\n\x20timestamps\x20are\x20returned\x20in\x20order\x20of\x20their\
    \x20`insert_id`\x20values.\n\n\x0f\n\x05\x04\x04\x02\x03\x04\x12\x06\xd1\
    \x01\x02\xc9\x01\x14\n\r\n\x05\x04\x04\x02\x03\x05\x12\x04\xd1\x01\x02\
    \x08\n\r\n\x05\x04\x04\x02\x03\x01\x12\x04\xd1\x01\t\x11\n\r\n\x05\x04\
    \x04\x02\x03\x03\x12\x04\xd1\x01\x14\x15\n\xdb\x01\n\x04\x04\x04\x02\x04\
    \x12\x04\xd6\x01\x02\x16\x1a\xcc\x01\x20Optional.\x20The\x20maximum\x20n\
    umber\x20of\x20results\x20to\x20return\x20from\x20this\x20request.\n\x20\
    Non-positive\x20values\x20are\x20ignored.\x20\x20The\x20presence\x20of\
    \x20`next_page_token`\x20in\x20the\n\x20response\x20indicates\x20that\
    \x20more\x20results\x20might\x20be\x20available.\n\n\x0f\n\x05\x04\x04\
    \x02\x04\x04\x12\x06\xd6\x01\x02\xd1\x01\x16\n\r\n\x05\x04\x04\x02\x04\
    \x05\x12\x04\xd6\x01\x02\x07\n\r\n\x05\x04\x04\x02\x04\x01\x12\x04\xd6\
    \x01\x08\x11\n\r\n\x05\x04\x04\x02\x04\x03\x12\x04\xd6\x01\x14\x15\n\xa4\
    \x02\n\x04\x04\x04\x02\x05\x12\x04\xdc\x01\x02\x18\x1a\x95\x02\x20Option\
    al.\x20If\x20present,\x20then\x20retrieve\x20the\x20next\x20batch\x20of\
    \x20results\x20from\x20the\n\x20preceding\x20call\x20to\x20this\x20metho\
    d.\x20\x20`page_token`\x20must\x20be\x20the\x20value\x20of\n\x20`next_pa\
    ge_token`\x20from\x20the\x20previous\x20response.\x20\x20The\x20values\
    \x20of\x20other\x20method\n\x20parameters\x20should\x20be\x20identical\
    \x20to\x20those\x20in\x20the\x20previous\x20call.\n\n\x0f\n\x05\x04\x04\
    \x02\x05\x04\x12\x06\xdc\x01\x02\xd6\x01\x16\n\r\n\x05\x04\x04\x02\x05\
    \x05\x12\x04\xdc\x01\x02\x08\n\r\n\x05\x04\x04\x02\x05\x01\x12\x04\xdc\
    \x01\t\x13\n\r\n\x05\x04\x04\x02\x05\x03\x12\x04\xdc\x01\x16\x17\n6\n\
    \x02\x04\x05\x12\x06\xe0\x01\0\xf1\x01\x01\x1a(\x20Result\x20returned\
    \x20from\x20`ListLogEntries`.\n\n\x0b\n\x03\x04\x05\x01\x12\x04\xe0\x01\
    \x08\x1e\n\xbb\x01\n\x04\x04\x05\x02\0\x12\x04\xe4\x01\x02\x20\x1a\xac\
    \x01\x20A\x20list\x20of\x20log\x20entries.\x20\x20If\x20`entries`\x20is\
    \x20empty,\x20`nextPageToken`\x20may\x20still\x20be\n\x20returned,\x20in\
    dicating\x20that\x20more\x20entries\x20may\x20exist.\x20\x20See\x20`next\
    PageToken`\x20for\n\x20more\x20information.\n\n\r\n\x05\x04\x05\x02\0\
    \x04\x12\x04\xe4\x01\x02\n\n\r\n\x05\x04\x05\x02\0\x06\x12\x04\xe4\x01\
    \x0b\x13\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xe4\x01\x14\x1b\n\r\n\x05\
    \x04\x05\x02\0\x03\x12\x04\xe4\x01\x1e\x1f\n\x9a\x05\n\x04\x04\x05\x02\
    \x01\x12\x04\xf0\x01\x02\x1d\x1a\x8b\x05\x20If\x20there\x20might\x20be\
    \x20more\x20results\x20than\x20those\x20appearing\x20in\x20this\x20respo\
    nse,\x20then\n\x20`nextPageToken`\x20is\x20included.\x20\x20To\x20get\
    \x20the\x20next\x20set\x20of\x20results,\x20call\x20this\n\x20method\x20\
    again\x20using\x20the\x20value\x20of\x20`nextPageToken`\x20as\x20`pageTo\
    ken`.\n\n\x20If\x20a\x20value\x20for\x20`next_page_token`\x20appears\x20\
    and\x20the\x20`entries`\x20field\x20is\x20empty,\n\x20it\x20means\x20tha\
    t\x20the\x20search\x20found\x20no\x20log\x20entries\x20so\x20far\x20but\
    \x20it\x20did\x20not\x20have\n\x20time\x20to\x20search\x20all\x20the\x20\
    possible\x20log\x20entries.\x20\x20Retry\x20the\x20method\x20with\x20thi\
    s\n\x20value\x20for\x20`page_token`\x20to\x20continue\x20the\x20search.\
    \x20\x20Alternatively,\x20consider\n\x20speeding\x20up\x20the\x20search\
    \x20by\x20changing\x20your\x20filter\x20to\x20specify\x20a\x20single\x20\
    log\x20name\n\x20or\x20resource\x20type,\x20or\x20to\x20narrow\x20the\
    \x20time\x20range\x20of\x20the\x20search.\n\n\x0f\n\x05\x04\x05\x02\x01\
    \x04\x12\x06\xf0\x01\x02\xe4\x01\x20\n\r\n\x05\x04\x05\x02\x01\x05\x12\
    \x04\xf0\x01\x02\x08\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\xf0\x01\t\x18\
    \n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\xf0\x01\x1b\x1c\nB\n\x02\x04\x06\
    \x12\x06\xf4\x01\0\xff\x01\x01\x1a4\x20The\x20parameters\x20to\x20ListMo\
    nitoredResourceDescriptors\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xf4\x01\x08\
    /\n\xd9\x01\n\x04\x04\x06\x02\0\x12\x04\xf8\x01\x02\x16\x1a\xca\x01\x20O\
    ptional.\x20The\x20maximum\x20number\x20of\x20results\x20to\x20return\
    \x20from\x20this\x20request.\n\x20Non-positive\x20values\x20are\x20ignor\
    ed.\x20\x20The\x20presence\x20of\x20`nextPageToken`\x20in\x20the\n\x20re\
    sponse\x20indicates\x20that\x20more\x20results\x20might\x20be\x20availab\
    le.\n\n\x0f\n\x05\x04\x06\x02\0\x04\x12\x06\xf8\x01\x02\xf4\x011\n\r\n\
    \x05\x04\x06\x02\0\x05\x12\x04\xf8\x01\x02\x07\n\r\n\x05\x04\x06\x02\0\
    \x01\x12\x04\xf8\x01\x08\x11\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xf8\x01\
    \x14\x15\n\xa1\x02\n\x04\x04\x06\x02\x01\x12\x04\xfe\x01\x02\x18\x1a\x92\
    \x02\x20Optional.\x20If\x20present,\x20then\x20retrieve\x20the\x20next\
    \x20batch\x20of\x20results\x20from\x20the\n\x20preceding\x20call\x20to\
    \x20this\x20method.\x20\x20`pageToken`\x20must\x20be\x20the\x20value\x20\
    of\n\x20`nextPageToken`\x20from\x20the\x20previous\x20response.\x20\x20T\
    he\x20values\x20of\x20other\x20method\n\x20parameters\x20should\x20be\
    \x20identical\x20to\x20those\x20in\x20the\x20previous\x20call.\n\n\x0f\n\
    \x05\x04\x06\x02\x01\x04\x12\x06\xfe\x01\x02\xf8\x01\x16\n\r\n\x05\x04\
    \x06\x02\x01\x05\x12\x04\xfe\x01\x02\x08\n\r\n\x05\x04\x06\x02\x01\x01\
    \x12\x04\xfe\x01\t\x13\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xfe\x01\x16\
    \x17\nF\n\x02\x04\x07\x12\x06\x82\x02\0\x8a\x02\x01\x1a8\x20Result\x20re\
    turned\x20from\x20ListMonitoredResourceDescriptors.\n\n\x0b\n\x03\x04\
    \x07\x01\x12\x04\x82\x02\x080\n/\n\x04\x04\x07\x02\0\x12\x04\x84\x02\x02\
    K\x1a!\x20A\x20list\x20of\x20resource\x20descriptors.\n\n\r\n\x05\x04\
    \x07\x02\0\x04\x12\x04\x84\x02\x02\n\n\r\n\x05\x04\x07\x02\0\x06\x12\x04\
    \x84\x02\x0b1\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\x84\x022F\n\r\n\x05\
    \x04\x07\x02\0\x03\x12\x04\x84\x02IJ\n\xe5\x01\n\x04\x04\x07\x02\x01\x12\
    \x04\x89\x02\x02\x1d\x1a\xd6\x01\x20If\x20there\x20might\x20be\x20more\
    \x20results\x20than\x20those\x20appearing\x20in\x20this\x20response,\x20\
    then\n\x20`nextPageToken`\x20is\x20included.\x20\x20To\x20get\x20the\x20\
    next\x20set\x20of\x20results,\x20call\x20this\n\x20method\x20again\x20us\
    ing\x20the\x20value\x20of\x20`nextPageToken`\x20as\x20`pageToken`.\n\n\
    \x0f\n\x05\x04\x07\x02\x01\x04\x12\x06\x89\x02\x02\x84\x02K\n\r\n\x05\
    \x04\x07\x02\x01\x05\x12\x04\x89\x02\x02\x08\n\r\n\x05\x04\x07\x02\x01\
    \x01\x12\x04\x89\x02\t\x18\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\x89\x02\
    \x1b\x1c\n+\n\x02\x04\x08\x12\x06\x8d\x02\0\xa0\x02\x01\x1a\x1d\x20The\
    \x20parameters\x20to\x20ListLogs.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\x8d\
    \x02\x08\x17\n\xcc\x01\n\x04\x04\x08\x02\0\x12\x04\x94\x02\x02\x14\x1a\
    \xbd\x01\x20Required.\x20The\x20resource\x20name\x20that\x20owns\x20the\
    \x20logs:\n\n\x20\x20\x20\x20\x20\"projects/[PROJECT_ID]\"\n\x20\x20\x20\
    \x20\x20\"organizations/[ORGANIZATION_ID]\"\n\x20\x20\x20\x20\x20\"billi\
    ngAccounts/[BILLING_ACCOUNT_ID]\"\n\x20\x20\x20\x20\x20\"folders/[FOLDER\
    _ID]\"\n\n\x0f\n\x05\x04\x08\x02\0\x04\x12\x06\x94\x02\x02\x8d\x02\x19\n\
    \r\n\x05\x04\x08\x02\0\x05\x12\x04\x94\x02\x02\x08\n\r\n\x05\x04\x08\x02\
    \0\x01\x12\x04\x94\x02\t\x0f\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\x94\x02\
    \x12\x13\n\xd9\x01\n\x04\x04\x08\x02\x01\x12\x04\x99\x02\x02\x16\x1a\xca\
    \x01\x20Optional.\x20The\x20maximum\x20number\x20of\x20results\x20to\x20\
    return\x20from\x20this\x20request.\n\x20Non-positive\x20values\x20are\
    \x20ignored.\x20\x20The\x20presence\x20of\x20`nextPageToken`\x20in\x20th\
    e\n\x20response\x20indicates\x20that\x20more\x20results\x20might\x20be\
    \x20available.\n\n\x0f\n\x05\x04\x08\x02\x01\x04\x12\x06\x99\x02\x02\x94\
    \x02\x14\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\x99\x02\x02\x07\n\r\n\x05\
    \x04\x08\x02\x01\x01\x12\x04\x99\x02\x08\x11\n\r\n\x05\x04\x08\x02\x01\
    \x03\x12\x04\x99\x02\x14\x15\n\xa1\x02\n\x04\x04\x08\x02\x02\x12\x04\x9f\
    \x02\x02\x18\x1a\x92\x02\x20Optional.\x20If\x20present,\x20then\x20retri\
    eve\x20the\x20next\x20batch\x20of\x20results\x20from\x20the\n\x20precedi\
    ng\x20call\x20to\x20this\x20method.\x20\x20`pageToken`\x20must\x20be\x20\
    the\x20value\x20of\n\x20`nextPageToken`\x20from\x20the\x20previous\x20re\
    sponse.\x20\x20The\x20values\x20of\x20other\x20method\n\x20parameters\
    \x20should\x20be\x20identical\x20to\x20those\x20in\x20the\x20previous\
    \x20call.\n\n\x0f\n\x05\x04\x08\x02\x02\x04\x12\x06\x9f\x02\x02\x99\x02\
    \x16\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\x9f\x02\x02\x08\n\r\n\x05\x04\
    \x08\x02\x02\x01\x12\x04\x9f\x02\t\x13\n\r\n\x05\x04\x08\x02\x02\x03\x12\
    \x04\x9f\x02\x16\x17\n.\n\x02\x04\t\x12\x06\xa3\x02\0\xad\x02\x01\x1a\
    \x20\x20Result\x20returned\x20from\x20ListLogs.\n\n\x0b\n\x03\x04\t\x01\
    \x12\x04\xa3\x02\x08\x18\n\x9c\x01\n\x04\x04\t\x02\0\x12\x04\xa7\x02\x02\
    \x20\x1a\x8d\x01\x20A\x20list\x20of\x20log\x20names.\x20For\x20example,\
    \n\x20`\"projects/my-project/syslog\"`\x20or\n\x20`\"organizations/123/c\
    loudresourcemanager.googleapis.com%2Factivity\"`.\n\n\r\n\x05\x04\t\x02\
    \0\x04\x12\x04\xa7\x02\x02\n\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xa7\x02\
    \x0b\x11\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xa7\x02\x12\x1b\n\r\n\x05\x04\
    \t\x02\0\x03\x12\x04\xa7\x02\x1e\x1f\n\xe5\x01\n\x04\x04\t\x02\x01\x12\
    \x04\xac\x02\x02\x1d\x1a\xd6\x01\x20If\x20there\x20might\x20be\x20more\
    \x20results\x20than\x20those\x20appearing\x20in\x20this\x20response,\x20\
    then\n\x20`nextPageToken`\x20is\x20included.\x20\x20To\x20get\x20the\x20\
    next\x20set\x20of\x20results,\x20call\x20this\n\x20method\x20again\x20us\
    ing\x20the\x20value\x20of\x20`nextPageToken`\x20as\x20`pageToken`.\n\n\
    \x0f\n\x05\x04\t\x02\x01\x04\x12\x06\xac\x02\x02\xa7\x02\x20\n\r\n\x05\
    \x04\t\x02\x01\x05\x12\x04\xac\x02\x02\x08\n\r\n\x05\x04\t\x02\x01\x01\
    \x12\x04\xac\x02\t\x18\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xac\x02\x1b\
    \x1cb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
